generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                          String                 @id @default(cuid())
  email                       String                 @unique
  name                        String?
  emailVerified               DateTime?
  image                       String?
  passwordHash                String?
  checksum                    String?
  createdAt                   DateTime               @default(now())
  updatedAt                   DateTime               @updatedAt
  systemRole                  SystemRole             @default(USER)
  intendedBusinessType        String? // Business type selected during registration (OBRT_PAUSAL, OBRT_REAL, OBRT_VAT, JDOO, DOO)
  betaOptIn                   Boolean                @default(false)
  betaOptInAt                 DateTime?
  accounts                    Account[]
  companies                   CompanyUser[]
  passwordResetTokens         PasswordResetToken[]
  sessions                    Session[]
  assignmentsMade             StaffAssignment[]      @relation("AssignmentsMade")
  staffAssignments            StaffAssignment[]      @relation("StaffAssignments")
  verificationCodes           VerificationCode[]
  webAuthnCredentials         WebAuthnCredential[]
  clientInvitations           ClientInvitation[]     @relation("ClientInvitations")
  betaFeedback                BetaFeedback[]
  staffReviews                StaffReview[]          @relation("StaffReviews")
  experimentAssignments       ExperimentAssignment[]
  experimentEvents            ExperimentEvent[]
  artifactsCreated            Artifact[]             @relation("ArtifactCreator")
  personSnapshots             PersonSnapshot[]       @relation("PersonSnapshotAuthor")
  travelOrders                TravelOrder[]          @relation("TravelOrderTraveler")
  mileageLogs                 MileageLog[]           @relation("MileageLogTraveler")
  generatedTravelPdfs         TravelPdf[]            @relation("TravelPdfGeneratedBy")
  closedAccountingPeriods     AccountingPeriod[]
  lockedAccountingPeriods     AccountingPeriod[]     @relation("AccountingPeriodLockedBy")
  journalEntriesCreated       JournalEntry[]
  payoutsLocked               Payout[]               @relation("PayoutLockedBy")
  payoutsReported             Payout[]               @relation("PayoutReportedBy")
  calculationSnapshotsCreated CalculationSnapshot[]  @relation("CalculationSnapshotCreator")
  payslipArtifactsCreated     PayslipArtifact[]      @relation("PayslipArtifactCreator")
  bankPaymentExportsCreated   BankPaymentExport[]    @relation("BankPaymentExportCreator")
  bankPaymentExportsExported  BankPaymentExport[]    @relation("BankPaymentExportExporter")
  reviewQueueRequested        ReviewQueueItem[]      @relation("ReviewQueueRequestedBy")
  reviewQueueAssigned         ReviewQueueItem[]      @relation("ReviewQueueAssignedTo")
  reviewQueueCompleted        ReviewQueueItem[]      @relation("ReviewQueueCompletedBy")
  reviewDecisions             ReviewDecision[]       @relation("ReviewDecisionDecider")
  reportingApprovals          ReportingStatus[]      @relation("ReportingStatusApprover")
  supportTicketsCreated       SupportTicket[]        @relation("SupportTicketCreatedBy")
  supportTicketsAssigned      SupportTicket[]        @relation("SupportTicketAssignedTo")
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model VerificationCode {
  id        String               @id @default(cuid())
  email     String
  userId    String?
  codeHash  String
  type      VerificationCodeType
  expiresAt DateTime
  attempts  Int                  @default(0)
  createdAt DateTime             @default(now())
  user      User?                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([expiresAt])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Company {
  id                             String                       @id @default(cuid())
  name                           String
  oib                            String                       @unique
  vatNumber                      String?
  address                        String
  city                           String
  postalCode                     String
  country                        String                       @default("HR")
  email                          String?
  phone                          String?
  iban                           String?
  checksum                       String?
  isVatPayer                     Boolean                      @default(false)
  eInvoiceProvider               String?
  createdAt                      DateTime                     @default(now())
  updatedAt                      DateTime                     @updatedAt
  eInvoiceApiKeyEncrypted        String?
  legalForm                      String?
  entitlements                   Json?
  featureFlags                   Json?
  deviceCode                     String                       @default("1")
  fiscalEnabled                  Boolean                      @default(false)
  fiscalEnvironment              FiscalEnv                    @default(PROD)
  premisesCode                   String                       @default("1")
  stripeCustomerId               String?                      @unique
  stripeSubscriptionId           String?                      @unique
  subscriptionStatus             String?                      @default("trialing")
  subscriptionPlan               String?                      @default("pausalni")
  trialEndsAt                    DateTime?
  subscriptionCurrentPeriodStart DateTime?
  subscriptionCurrentPeriodEnd   DateTime?
  invoiceLimit                   Int                          @default(50)
  userLimit                      Int                          @default(1)
  stripeTerminalLocationId       String?
  stripeTerminalReaderId         String?
  stockValuationMethod           StockValuationMethod         @default(WEIGHTED_AVERAGE)
  onboardingStep                 Int                          @default(1)
  aiUsage                        AIUsage[]
  auditLogs                      AuditLog[]
  bankAccounts                   BankAccount[]
  bankConnections                BankConnection[]
  businessPremises               BusinessPremises[]
  users                          CompanyUser[]
  contacts                       Contact[]
  people                         Person[]
  personContactRoles             PersonContactRole[]
  personEmployeeRoles            PersonEmployeeRole[]
  personDirectorRoles            PersonDirectorRole[]
  personSnapshots                PersonSnapshot[]
  personEvents                   PersonEvent[]
  eInvoices                      EInvoice[]
  emailAttachments               EmailAttachment[]
  emailConnections               EmailConnection[]
  emailImportRules               EmailImportRule[]
  expenses                       Expense[]
  expenseLines                   ExpenseLine[]
  supplierBills                  SupplierBill[]
  uraInputs                      UraInput[]
  attachments                    Attachment[]
  expenseCorrections             ExpenseCorrection[]
  fixedAssetCandidates           FixedAssetCandidate[]
  expenseCategories              ExpenseCategory[]
  fiscalCertificates             FiscalCertificate[]
  fiscalRequests                 FiscalRequest[]
  integrationAccounts            IntegrationAccount[]
  importJobs                     ImportJob[]
  invoiceSequences               InvoiceSequence[]
  payouts                        Payout[]
  mileageLogs                    MileageLog[]
  paymentDevices                 PaymentDevice[]
  potentialDuplicates            PotentialDuplicate[]
  products                       Product[]
  warehouses                     Warehouse[]
  stockItems                     StockItem[]
  stockMovements                 StockMovement[]
  valuationSnapshots             ValuationSnapshot[]
  recurringExpenses              RecurringExpense[]
  savedReports                   SavedReport[]
  assignedStaff                  StaffAssignment[]            @relation("AssignedStaff")
  statements                     Statement[]
  statementPages                 StatementPage[]
  supportTickets                 SupportTicket[]
  joppdSubmissions               JoppdSubmission[]
  payoutLines                    PayoutLine[]
  calculationSnapshots           CalculationSnapshot[]
  appliedRuleSnapshots           AppliedRuleSnapshot[]
  payslips                       Payslip[]
  payslipArtifacts               PayslipArtifact[]
  bankPaymentExports             BankPaymentExport[]
  bankPaymentLines               BankPaymentLine[]
  statementTransactions          Transaction[]
  travelOrders                   TravelOrder[]
  travelPdfs                     TravelPdf[]
  clientInvitations              ClientInvitation[]           @relation("InvitedClients")
  entitlementHistory             EntitlementHistory[]
  featureFlagOverrides           FeatureFlagOverride[]
  staffReviews                   StaffReview[]
  adminAlerts                    AdminAlert[]
  statementImports               StatementImport[]
  chartOfAccounts                ChartOfAccounts[]
  accountingPeriods              AccountingPeriod[]
  journalEntries                 JournalEntry[]
  trialBalances                  TrialBalance[]
  postingRules                   PostingRule[]
  operationalEvents              OperationalEvent[]
  fixedAssets                    FixedAsset[]
  assetCandidates                AssetCandidate[]
  cashIns                        CashIn[]
  cashOuts                       CashOut[]
  cashDayCloses                  CashDayClose[]
  cashLimitSetting               CashLimitSetting?
  employees                      Employee[]
  artifacts                      Artifact[]
  employeeRoles                  EmployeeRole[]
  employmentContracts            EmploymentContract[]
  employmentContractVersions     EmploymentContractVersion[]
  employmentTerminationEvents    EmploymentTerminationEvent[]
  dependents                     Dependent[]
  allowances                     Allowance[]
  pensionPillars                 PensionPillar[]
  revenueRegisterEntries         RevenueRegisterEntry[]
  invoiceEvents                  InvoiceEvent[]
  matchRecords                   MatchRecord[]
  unappliedPayments              UnappliedPayment[]
  accountMappings                AccountMapping[]
  exportProfiles                 ExportProfile[]
  exportJobs                     ExportJob[]
  reviewQueueItems               ReviewQueueItem[]
  reviewDecisions                ReviewDecision[]
  reportingStatuses              ReportingStatus[]
  addresses                      Address[]
  organizations                  Organization[]
  taxIdentities                  TaxIdentity[]
  documents                      Document[]
  providerSyncStates             ProviderSyncState[]
}

model ChartOfAccounts {
  id              String               @id @default(cuid())
  companyId       String
  code            String
  name            String
  description     String?
  normalBalance   AccountNormalBalance
  statementType   StatementType
  lockLevel       AccountLockLevel     @default(USER)
  isActive        Boolean              @default(true)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  company         Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  journalLines    JournalLine[]
  trialBalances   TrialBalance[]
  debitRules      PostingRule[]        @relation("DebitPostingRules")
  creditRules     PostingRule[]        @relation("CreditPostingRules")
  vatRules        PostingRule[]        @relation("VatPostingRules")
  accountMappings AccountMapping[]

  @@unique([companyId, code])
  @@index([companyId])
  @@index([companyId, statementType])
}

model AccountingPeriod {
  id                String            @id @default(cuid())
  companyId         String
  fiscalYear        Int
  periodNumber      Int
  periodType        PeriodType        @default(MONTHLY)
  startDate         DateTime
  endDate           DateTime
  status            PeriodStatus      @default(OPEN)
  closedAt          DateTime?
  closedById        String?
  lockedAt          DateTime?
  lockedById        String?
  lockReason        String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  company           Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  closedBy          User?             @relation(fields: [closedById], references: [id])
  lockedBy          User?             @relation("AccountingPeriodLockedBy", fields: [lockedById], references: [id])
  journalEntries    JournalEntry[]
  trialBalances     TrialBalance[]
  reportingStatuses ReportingStatus[]

  @@unique([companyId, fiscalYear, periodNumber])
  @@index([companyId, status])
}

model ReportingStatus {
  id                String           @id @default(cuid())
  companyId         String
  periodId          String
  reportType        ReportType
  status            ReportingState   @default(DRAFT)
  reviewQueueItemId String?          @unique
  submittedAt       DateTime?
  approvedAt        DateTime?
  approvedById      String?
  notes             String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  company           Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  period            AccountingPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  approvedBy        User?            @relation("ReportingStatusApprover", fields: [approvedById], references: [id])
  reviewQueueItem   ReviewQueueItem? @relation("ReportingStatusReviewQueue", fields: [reviewQueueItemId], references: [id], onDelete: SetNull)

  @@unique([companyId, periodId, reportType])
  @@index([companyId, status])
  @@index([periodId])
}

model ReviewQueueItem {
  id              String                @id @default(cuid())
  companyId       String
  entityType      ReviewQueueEntityType
  entityId        String
  status          ReviewQueueStatus     @default(PENDING)
  priority        ReviewQueuePriority   @default(NORMAL)
  requestedById   String?
  requestedAt     DateTime              @default(now())
  assignedToId    String?
  assignedAt      DateTime?
  dueAt           DateTime?
  completedAt     DateTime?
  completedById   String?
  notes           String?
  metadata        Json?
  company         Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  requestedBy     User?                 @relation("ReviewQueueRequestedBy", fields: [requestedById], references: [id])
  assignedTo      User?                 @relation("ReviewQueueAssignedTo", fields: [assignedToId], references: [id])
  completedBy     User?                 @relation("ReviewQueueCompletedBy", fields: [completedById], references: [id])
  decisions       ReviewDecision[]
  reportingStatus ReportingStatus?      @relation("ReportingStatusReviewQueue")

  @@index([companyId, status])
  @@index([entityType, entityId])
  @@index([assignedToId])
}

model ReviewDecision {
  id          String             @id @default(cuid())
  companyId   String
  reviewId    String
  decision    ReviewDecisionType
  notes       String?
  decidedById String?
  decidedAt   DateTime           @default(now())
  company     Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  review      ReviewQueueItem    @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  decidedBy   User?              @relation("ReviewDecisionDecider", fields: [decidedById], references: [id])

  @@index([companyId])
  @@index([reviewId])
  @@index([decidedAt])
}

model JournalEntry {
  id                     String              @id @default(cuid())
  companyId              String
  entryNumber            Int
  fiscalYear             Int
  entryDate              DateTime
  periodId               String
  status                 EntryStatus         @default(DRAFT)
  description            String
  reference              String?
  contentHash            String
  hashAlgoVersion        Int                 @default(1)
  canonicalFormatVersion Int                 @default(1)
  createdById            String?
  createdAt              DateTime            @default(now())
  postedAt               DateTime?
  company                Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  period                 AccountingPeriod    @relation(fields: [periodId], references: [id], onDelete: Restrict)
  createdBy              User?               @relation(fields: [createdById], references: [id])
  lines                  JournalLine[]
  depreciationEntries    DepreciationEntry[]
  operationalEvents      OperationalEvent[]

  @@unique([companyId, fiscalYear, entryNumber])
  @@index([companyId, entryDate])
  @@index([companyId, status])
  @@index([periodId])
}

model JournalLine {
  id             String          @id @default(cuid())
  journalEntryId String
  accountId      String
  debit          Decimal         @db.Decimal(14, 2)
  credit         Decimal         @db.Decimal(14, 2)
  lineNumber     Int
  description    String?
  dimensions     Json?
  createdAt      DateTime        @default(now())
  journalEntry   JournalEntry    @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)
  account        ChartOfAccounts @relation(fields: [accountId], references: [id], onDelete: Restrict)

  @@index([journalEntryId])
  @@index([accountId])
}

model TrialBalance {
  id          String           @id @default(cuid())
  companyId   String
  periodId    String
  accountId   String
  debitTotal  Decimal          @db.Decimal(14, 2)
  creditTotal Decimal          @db.Decimal(14, 2)
  netBalance  Decimal          @db.Decimal(14, 2)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  company     Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  period      AccountingPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  account     ChartOfAccounts  @relation(fields: [accountId], references: [id], onDelete: Restrict)

  @@unique([companyId, periodId, accountId])
  @@index([companyId, periodId])
  @@index([accountId])
}

model PostingRule {
  id              String                @id @default(cuid())
  companyId       String
  sourceType      OperationalSourceType
  eventType       OperationalEventType
  debitAccountId  String
  creditAccountId String
  vatAccountId    String? // New field for Tax account (e.g. Output/Input VAT)
  description     String?
  isActive        Boolean               @default(true)
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  company         Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  debitAccount    ChartOfAccounts       @relation("DebitPostingRules", fields: [debitAccountId], references: [id], onDelete: Restrict)
  creditAccount   ChartOfAccounts       @relation("CreditPostingRules", fields: [creditAccountId], references: [id], onDelete: Restrict)
  vatAccount      ChartOfAccounts?      @relation("VatPostingRules", fields: [vatAccountId], references: [id], onDelete: Restrict)

  @@unique([companyId, sourceType, eventType])
  @@index([companyId])
}

model OperationalEvent {
  id             String                 @id @default(cuid())
  companyId      String
  sourceType     OperationalSourceType
  eventType      OperationalEventType
  sourceId       String
  entryDate      DateTime
  status         OperationalEventStatus @default(PENDING)
  journalEntryId String?
  payload        Json?
  errorMessage   String?
  createdAt      DateTime               @default(now())
  processedAt    DateTime?
  company        Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  journalEntry   JournalEntry?          @relation(fields: [journalEntryId], references: [id], onDelete: SetNull)

  @@unique([companyId, sourceType, sourceId, eventType])
  @@index([companyId, status])
}

// ============================================================================
// EXPORTS & INTEGRATIONS
// ============================================================================

model ExportProfile {
  id              String             @id @default(cuid())
  companyId       String
  name            String
  targetSystem    ExportTargetSystem
  isDefault       Boolean            @default(false)
  settings        Json?
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  company         Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  accountMappings AccountMapping[]
  exportJobs      ExportJob[]

  @@index([companyId])
  @@index([companyId, targetSystem])
}

model AccountMapping {
  id                  String          @id @default(cuid())
  companyId           String
  exportProfileId     String
  chartOfAccountsId   String
  externalAccountCode String
  externalAccountName String?
  notes               String?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  company             Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  exportProfile       ExportProfile   @relation(fields: [exportProfileId], references: [id], onDelete: Cascade)
  chartOfAccounts     ChartOfAccounts @relation(fields: [chartOfAccountsId], references: [id], onDelete: Restrict)

  @@unique([exportProfileId, chartOfAccountsId])
  @@index([companyId])
  @@index([chartOfAccountsId])
}

model ExportJob {
  id               String          @id @default(cuid())
  companyId        String
  exportProfileId  String
  status           ExportJobStatus @default(PENDING)
  periodFrom       DateTime?
  periodTo         DateTime?
  recordCount      Int             @default(0)
  fileName         String?
  controlSum       String?
  validationReport Json?
  errorMessage     String?
  completedAt      DateTime?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  company          Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  exportProfile    ExportProfile   @relation(fields: [exportProfileId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([exportProfileId])
  @@index([status])
}

// ============================================================================
// EMPLOYMENT & PAYROLL
// ============================================================================

model Employee {
  id          String    @id @default(cuid())
  companyId   String
  firstName   String
  lastName    String
  oib         String?
  dateOfBirth DateTime?
  email       String?
  phone       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  company                     Company                      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employmentContracts         EmploymentContract[]
  roles                       EmployeeRole[]
  dependents                  Dependent[]
  allowances                  Allowance[]
  pensionPillars              PensionPillar[]
  employmentTerminationEvents EmploymentTerminationEvent[]
  payoutLines                 PayoutLine[]
  payslips                    Payslip[]

  @@unique([companyId, oib])
  @@index([companyId])
  @@index([lastName])
}

model EmployeeRole {
  id            String    @id @default(cuid())
  companyId     String
  employeeId    String
  title         String
  description   String?
  effectiveFrom DateTime
  effectiveTo   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([employeeId, effectiveFrom])
}

model EmploymentContract {
  id           String                   @id @default(cuid())
  companyId    String
  employeeId   String
  contractCode String?
  startedAt    DateTime
  endedAt      DateTime?
  status       EmploymentContractStatus @default(ACTIVE)
  createdAt    DateTime                 @default(now())
  updatedAt    DateTime                 @updatedAt

  company           Company                      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee          Employee                     @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  versions          EmploymentContractVersion[]
  terminationEvents EmploymentTerminationEvent[]

  @@index([companyId])
  @@index([employeeId])
  @@index([startedAt])
  @@index([endedAt])
}

model EmploymentContractVersion {
  id             String          @id @default(cuid())
  companyId      String
  contractId     String
  version        Int
  effectiveFrom  DateTime
  effectiveTo    DateTime?
  roleTitle      String?
  employmentType EmploymentType?
  hoursPerWeek   Int?
  salaryAmount   Decimal?        @db.Decimal(12, 2)
  salaryCurrency String          @default("EUR")
  createdAt      DateTime        @default(now())

  company  Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  contract EmploymentContract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@unique([contractId, version])
  @@index([companyId])
  @@index([contractId, effectiveFrom])
}

model EmploymentTerminationEvent {
  id           String            @id @default(cuid())
  companyId    String
  contractId   String
  employeeId   String
  terminatedAt DateTime
  reason       TerminationReason
  notes        String?
  createdAt    DateTime          @default(now())

  company  Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  contract EmploymentContract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  employee Employee           @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([contractId])
  @@index([employeeId])
  @@index([terminatedAt])
}

model Dependent {
  id            String            @id @default(cuid())
  companyId     String
  employeeId    String
  fullName      String
  relation      DependentRelation
  birthDate     DateTime?
  oib           String?
  isDisabled    Boolean           @default(false)
  effectiveFrom DateTime
  effectiveTo   DateTime?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([employeeId, effectiveFrom])
}

model Allowance {
  id            String        @id @default(cuid())
  companyId     String
  employeeId    String
  type          AllowanceType
  amount        Decimal       @db.Decimal(12, 2)
  currency      String        @default("EUR")
  taxable       Boolean       @default(false)
  effectiveFrom DateTime
  effectiveTo   DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([employeeId, effectiveFrom])
}

model PensionPillar {
  id               String            @id @default(cuid())
  companyId        String
  employeeId       String
  pillar           PensionPillarType
  fundName         String?
  contributionRate Decimal?          @db.Decimal(5, 2)
  effectiveFrom    DateTime
  effectiveTo      DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([employeeId, effectiveFrom])
}

// Audit trail for module entitlement changes
model EntitlementHistory {
  id            String                @id @default(cuid())
  companyId     String
  userId        String
  changeType    EntitlementChangeType
  moduleKey     String?
  previousValue Json?
  newValue      Json?
  previousPlan  String?
  newPlan       String?
  reason        String?
  metadata      Json?
  ipAddress     String?
  userAgent     String?
  createdAt     DateTime              @default(now())
  company       Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([userId])
  @@index([changeType])
  @@index([moduleKey])
  @@index([createdAt])
}

model CompanyUser {
  id                 String    @id @default(cuid())
  userId             String
  companyId          String
  role               Role      @default(MEMBER)
  isDefault          Boolean   @default(false)
  createdAt          DateTime  @default(now())
  notificationSeenAt DateTime?
  company            Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, companyId])
  @@index([userId])
  @@index([companyId])
}

model StaffAssignment {
  id         String   @id @default(cuid())
  staffId    String
  companyId  String
  assignedAt DateTime @default(now())
  assignedBy String
  notes      String?
  assigner   User     @relation("AssignmentsMade", fields: [assignedBy], references: [id])
  company    Company  @relation("AssignedStaff", fields: [companyId], references: [id], onDelete: Cascade)
  staff      User     @relation("StaffAssignments", fields: [staffId], references: [id], onDelete: Cascade)

  @@unique([staffId, companyId])
  @@index([staffId])
  @@index([companyId])
}

model ClientInvitation {
  id          String                 @id @default(cuid())
  staffId     String
  email       String
  companyName String?
  message     String?
  token       String                 @unique @default(cuid())
  status      ClientInvitationStatus @default(PENDING)
  createdAt   DateTime               @default(now())
  expiresAt   DateTime
  acceptedAt  DateTime?
  companyId   String?
  staff       User                   @relation("ClientInvitations", fields: [staffId], references: [id], onDelete: Cascade)
  company     Company?               @relation("InvitedClients", fields: [companyId], references: [id])

  @@index([staffId])
  @@index([email])
  @@index([token])
}

// Staff review tracking for accountant workflow (Pregledano feature)
model StaffReview {
  id         String            @id @default(cuid())
  companyId  String
  reviewerId String
  entityType StaffReviewEntity
  entityId   String
  reviewedAt DateTime          @default(now())
  notes      String?
  company    Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reviewer   User              @relation("StaffReviews", fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([companyId, entityType, entityId])
  @@index([companyId])
  @@index([reviewerId])
  @@index([entityType, entityId])
}

model Contact {
  id                String        @id @default(cuid())
  companyId         String
  type              ContactType
  name              String
  oib               String?
  vatNumber         String?
  address           String?
  city              String?
  postalCode        String?
  country           String        @default("HR")
  email             String?
  phone             String?
  organizationId    String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  paymentTermsDays  Int           @default(15)
  company           Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  organization      Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  eInvoicesAsBuyer  EInvoice[]    @relation("EInvoiceBuyer")
  eInvoicesAsSeller EInvoice[]    @relation("EInvoiceSeller")
  expensesAsVendor  Expense[]     @relation("ExpenseVendor")

  @@unique([companyId, oib])
  @@index([companyId])
  @@index([oib])
  @@index([organizationId])
}

model Address {
  id            String         @id @default(cuid())
  companyId     String
  line1         String
  line2         String?
  city          String
  postalCode    String?
  country       String         @default("HR")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  company       Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  organizations Organization[] @relation("OrganizationPrimaryAddress")

  @@unique([companyId, line1, line2, city, postalCode, country])
  @@index([companyId])
  @@index([city])
}

model Organization {
  id                       String            @id @default(cuid())
  companyId                String
  legalName                String
  normalizedLegalName      String
  email                    String?
  phone                    String?
  primaryAddressId         String?
  createdAt                DateTime          @default(now())
  updatedAt                DateTime          @updatedAt
  company                  Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  primaryAddress           Address?          @relation("OrganizationPrimaryAddress", fields: [primaryAddressId], references: [id], onDelete: SetNull)
  taxIdentities            TaxIdentity[]
  contacts                 Contact[]
  bankAccounts             BankAccount[]
  buyerInvoices            EInvoice[]        @relation("EInvoiceBuyerOrganization")
  sellerInvoices           EInvoice[]        @relation("EInvoiceSellerOrganization")
  vendorExpenses           Expense[]         @relation("ExpenseVendorOrganization")
  counterpartyTransactions BankTransaction[] @relation("BankTransactionCounterpartyOrganization")

  @@unique([companyId, normalizedLegalName])
  @@index([companyId])
  @@index([normalizedLegalName])
  @@index([primaryAddressId])
}

model TaxIdentity {
  id             String          @id @default(cuid())
  companyId      String
  type           TaxIdentityType
  value          String
  country        String          @default("HR")
  organizationId String?
  personId       String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  company        Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  organization   Organization?   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  person         Person?         @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([companyId, type, value])
  @@index([companyId])
  @@index([organizationId])
  @@index([personId])
  @@index([type])
}

model Person {
  id                 String               @id @default(cuid())
  companyId          String
  fullName           String
  normalizedFullName String
  firstName          String?
  lastName           String?
  oib                String?
  email              String?
  phone              String?
  iban               String?
  addressLine1       String?
  addressLine2       String?
  city               String?
  postalCode         String?
  country            String               @default("HR")
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  company            Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  contactRoles       PersonContactRole[]
  employeeRoles      PersonEmployeeRole[]
  directorRoles      PersonDirectorRole[]
  snapshots          PersonSnapshot[]
  events             PersonEvent[]
  taxIdentities      TaxIdentity[]

  @@unique([companyId, normalizedFullName])
  @@unique([companyId, oib])
  @@index([companyId])
  @@index([oib])
  @@index([normalizedFullName])
}

model PersonContactRole {
  id               String      @id @default(cuid())
  companyId        String
  personId         String
  type             ContactType
  paymentTermsDays Int         @default(15)
  notes            String?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  company          Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  person           Person      @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([companyId, personId])
  @@index([companyId])
  @@index([personId])
  @@index([type])
}

model PersonEmployeeRole {
  id        String    @id @default(cuid())
  companyId String
  personId  String
  jobTitle  String?
  startDate DateTime?
  endDate   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  company   Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  person    Person    @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([companyId, personId])
  @@index([companyId])
  @@index([personId])
}

model PersonDirectorRole {
  id              String    @id @default(cuid())
  companyId       String
  personId        String
  appointmentDate DateTime?
  resignationDate DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  company         Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  person          Person    @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([companyId, personId])
  @@index([companyId])
  @@index([personId])
}

model PersonSnapshot {
  id               String               @id @default(cuid())
  companyId        String
  personId         String
  action           PersonSnapshotAction
  data             Json
  capturedAt       DateTime             @default(now())
  capturedByUserId String?
  company          Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  person           Person               @relation(fields: [personId], references: [id], onDelete: Cascade)
  capturedByUser   User?                @relation("PersonSnapshotAuthor", fields: [capturedByUserId], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([personId])
  @@index([capturedAt])
}

model PersonEvent {
  id        String          @id @default(cuid())
  companyId String
  personId  String
  eventType PersonEventType
  payload   Json
  createdAt DateTime        @default(now())
  company   Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  person    Person          @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([personId])
  @@index([eventType])
  @@index([createdAt])
}

model Product {
  id                 String              @id @default(cuid())
  companyId          String
  name               String
  description        String?
  sku                String?
  unit               String              @default("C62")
  price              Decimal             @db.Decimal(10, 2)
  vatRate            Decimal             @default(25) @db.Decimal(5, 2)
  vatCategory        String              @default("S")
  isActive           Boolean             @default(true)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  company            Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  stockItems         StockItem[]
  stockMovements     StockMovement[]
  valuationSnapshots ValuationSnapshot[]

  @@unique([companyId, sku])
  @@index([companyId])
}

model Warehouse {
  id                 String              @id @default(cuid())
  companyId          String
  name               String
  code               String?
  address            String?
  city               String?
  postalCode         String?
  country            String              @default("HR")
  isDefault          Boolean             @default(false)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  company            Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  stockItems         StockItem[]
  stockMovements     StockMovement[]
  valuationSnapshots ValuationSnapshot[]

  @@unique([companyId, name])
  @@unique([companyId, code])
  @@index([companyId])
}

model StockItem {
  id                 String              @id @default(cuid())
  companyId          String
  warehouseId        String
  productId          String
  quantityOnHand     Decimal             @default(0) @db.Decimal(14, 3)
  averageCost        Decimal?            @db.Decimal(10, 2)
  lastMovementAt     DateTime?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  company            Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  warehouse          Warehouse           @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  product            Product             @relation(fields: [productId], references: [id], onDelete: Restrict)
  movements          StockMovement[]
  valuationSnapshots ValuationSnapshot[]

  @@unique([warehouseId, productId])
  @@index([companyId])
  @@index([productId])
}

model StockMovement {
  id                 String              @id @default(cuid())
  companyId          String
  warehouseId        String
  productId          String
  stockItemId        String?
  movementType       StockMovementType
  quantity           Decimal             @db.Decimal(14, 3)
  unitCost           Decimal?            @db.Decimal(10, 2)
  movementDate       DateTime            @default(now())
  referenceNumber    String?
  eInvoiceLineId     String?
  expenseId          String?
  createdAt          DateTime            @default(now())
  company            Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  warehouse          Warehouse           @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  product            Product             @relation(fields: [productId], references: [id], onDelete: Restrict)
  stockItem          StockItem?          @relation(fields: [stockItemId], references: [id], onDelete: SetNull)
  eInvoiceLine       EInvoiceLine?       @relation(fields: [eInvoiceLineId], references: [id], onDelete: SetNull)
  expense            Expense?            @relation(fields: [expenseId], references: [id], onDelete: SetNull)
  valuationSnapshots ValuationSnapshot[]

  @@index([companyId])
  @@index([warehouseId])
  @@index([productId])
  @@index([movementDate])
  @@index([eInvoiceLineId])
  @@index([expenseId])
}

model ValuationSnapshot {
  id              String               @id @default(cuid())
  companyId       String
  warehouseId     String
  productId       String
  stockItemId     String?
  movementId      String?
  valuationMethod StockValuationMethod
  quantityOnHand  Decimal              @db.Decimal(14, 3)
  value           Decimal              @db.Decimal(14, 2)
  asOfDate        DateTime
  createdAt       DateTime             @default(now())
  company         Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  warehouse       Warehouse            @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  product         Product              @relation(fields: [productId], references: [id], onDelete: Restrict)
  stockItem       StockItem?           @relation(fields: [stockItemId], references: [id], onDelete: SetNull)
  movement        StockMovement?       @relation(fields: [movementId], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([warehouseId])
  @@index([productId])
  @@index([asOfDate])
}

model EInvoice {
  id                     String                 @id @default(cuid())
  companyId              String
  direction              EInvoiceDirection
  sellerId               String?
  buyerId                String?
  sellerOrganizationId   String?
  buyerOrganizationId    String?
  invoiceNumber          String
  issueDate              DateTime
  dueDate                DateTime?
  currency               String                 @default("EUR")
  buyerReference         String?
  netAmount              Decimal                @db.Decimal(10, 2)
  vatAmount              Decimal                @db.Decimal(10, 2)
  totalAmount            Decimal                @db.Decimal(10, 2)
  status                 EInvoiceStatus         @default(DRAFT)
  jir                    String?
  zki                    String?
  fiscalizedAt           DateTime?
  ublXml                 String?
  providerRef            String?
  providerStatus         String?
  providerError          String?
  archivedAt             DateTime?
  archiveRef             String?
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  sentAt                 DateTime?
  receivedAt             DateTime?
  type                   InvoiceType            @default(E_INVOICE)
  internalReference      String?
  notes                  String?
  convertedFromId        String?
  correctsInvoiceId      String?
  paidAt                 DateTime?
  paidAmount             Decimal                @default(0) @db.Decimal(12, 2)
  paymentStatus          InvoicePaymentStatus   @default(UNPAID)
  bankAccount            String?
  includeBarcode         Boolean                @default(true)
  importJobId            String?                @unique
  paymentModel           String?
  paymentReference       String?
  vendorBankName         String?
  vendorIban             String?
  fiscalStatus           String?
  operatorOib            String?
  paymentMethod          PaymentMethod?
  emailMessageId         String?
  emailDeliveredAt       DateTime?
  emailOpenedAt          DateTime?
  emailClickedAt         DateTime?
  emailBouncedAt         DateTime?
  emailBounceReason      String?
  bankTransactions       BankTransaction[]
  buyer                  Contact?               @relation("EInvoiceBuyer", fields: [buyerId], references: [id], onDelete: SetNull)
  buyerOrganization      Organization?          @relation("EInvoiceBuyerOrganization", fields: [buyerOrganizationId], references: [id], onDelete: SetNull)
  company                Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  convertedFrom          EInvoice?              @relation("InvoiceConversion", fields: [convertedFromId], references: [id])
  convertedTo            EInvoice[]             @relation("InvoiceConversion")
  correctsInvoice        EInvoice?              @relation("InvoiceCorrections", fields: [correctsInvoiceId], references: [id])
  creditNotes            EInvoice[]             @relation("InvoiceCorrections")
  importJob              ImportJob?             @relation(fields: [importJobId], references: [id])
  seller                 Contact?               @relation("EInvoiceSeller", fields: [sellerId], references: [id], onDelete: SetNull)
  sellerOrganization     Organization?          @relation("EInvoiceSellerOrganization", fields: [sellerOrganizationId], references: [id], onDelete: SetNull)
  lines                  EInvoiceLine[]
  fiscalRequests         FiscalRequest[]
  revenueRegisterEntries RevenueRegisterEntry[]
  invoiceEvents          InvoiceEvent[]
  matchRecords           MatchRecord[]

  // Integration account used for sending (Phase 2+)
  integrationAccountId   String?
  integrationAccount     IntegrationAccount? @relation(fields: [integrationAccountId], references: [id])

  @@unique([companyId, invoiceNumber])
  @@index([companyId])
  @@index([status])
  @@index([invoiceNumber])
  @@index([direction])
  @@index([type])
  @@index([emailMessageId])
  @@index([sellerId])
  @@index([buyerId])
  @@index([sellerOrganizationId])
  @@index([buyerOrganizationId])
  @@index([correctsInvoiceId])
  @@index([integrationAccountId])
}

model EInvoiceLine {
  id             String          @id @default(cuid())
  eInvoiceId     String
  lineNumber     Int
  description    String
  quantity       Decimal         @db.Decimal(10, 3)
  unit           String          @default("C62")
  unitPrice      Decimal         @db.Decimal(10, 2)
  netAmount      Decimal         @db.Decimal(10, 2)
  vatRate        Decimal         @db.Decimal(5, 2)
  vatCategory    String          @default("S")
  vatAmount      Decimal         @db.Decimal(10, 2)
  vatRuleId      String?
  eInvoice       EInvoice        @relation(fields: [eInvoiceId], references: [id], onDelete: Cascade)
  vatRule        RegulatoryRule? @relation(fields: [vatRuleId], references: [id])
  stockMovements StockMovement[]

  @@index([eInvoiceId])
  @@index([vatRuleId])
}

model EmailSuppression {
  id           String    @id @default(cuid())
  email        String    @unique
  reason       String
  details      String?
  suppressedAt DateTime  @default(now())
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([email])
  @@index([suppressedAt])
  @@index([expiresAt])
}

model RevenueRegisterEntry {
  id          String   @id @default(cuid())
  companyId   String
  invoiceId   String   @unique
  issueDate   DateTime
  netAmount   Decimal  @db.Decimal(10, 2)
  vatAmount   Decimal  @db.Decimal(10, 2)
  totalAmount Decimal  @db.Decimal(10, 2)
  currency    String   @default("EUR")
  createdAt   DateTime @default(now())

  company Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invoice EInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([issueDate])
}

model InvoiceEvent {
  id        String           @id @default(cuid())
  companyId String
  invoiceId String
  type      InvoiceEventType
  payload   Json?
  createdAt DateTime         @default(now())

  company Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invoice EInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@unique([invoiceId, type])
  @@index([companyId])
  @@index([type])
}

model AuditLog {
  id        String      @id @default(cuid())
  companyId String
  userId    String?
  actor     String      @default("system")
  action    AuditAction
  entity    String
  entityId  String
  changes   Json?
  ipAddress String?
  userAgent String?
  reason    String      @default("unspecified")
  checksum  String?
  timestamp DateTime    @default(now())
  company   Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([entity, entityId])
  @@index([timestamp])
}

model CashIn {
  id           String   @id @default(cuid())
  companyId    String
  businessDate DateTime @db.Date
  amount       Decimal  @db.Decimal(14, 2)
  note         String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([businessDate])
}

model CashOut {
  id           String   @id @default(cuid())
  companyId    String
  businessDate DateTime @db.Date
  amount       Decimal  @db.Decimal(14, 2)
  note         String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([businessDate])
}

model CashDayClose {
  id             String   @id @default(cuid())
  companyId      String
  businessDate   DateTime @db.Date
  openingBalance Decimal  @db.Decimal(14, 2)
  totalIn        Decimal  @db.Decimal(14, 2)
  totalOut       Decimal  @db.Decimal(14, 2)
  closingBalance Decimal  @db.Decimal(14, 2)
  note           String?
  closedAt       DateTime @default(now())
  company        Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, businessDate])
  @@index([companyId])
  @@index([businessDate])
}

model CashLimitSetting {
  id          String   @id @default(cuid())
  companyId   String   @unique
  limitAmount Decimal  @db.Decimal(14, 2)
  currency    String   @default("EUR")
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
}

model BusinessPremises {
  id        String            @id @default(cuid())
  companyId String
  code      Int
  name      String
  address   String?
  isDefault Boolean           @default(false)
  isActive  Boolean           @default(true)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  company   Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  sequences InvoiceSequence[]
  devices   PaymentDevice[]

  @@unique([companyId, code])
  @@index([companyId])
}

model PaymentDevice {
  id                 String           @id @default(cuid())
  companyId          String
  businessPremisesId String
  code               Int
  name               String
  isDefault          Boolean          @default(false)
  isActive           Boolean          @default(true)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  businessPremises   BusinessPremises @relation(fields: [businessPremisesId], references: [id], onDelete: Cascade)
  company            Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([businessPremisesId, code])
  @@index([companyId])
}

model InvoiceSequence {
  id                 String           @id @default(cuid())
  companyId          String
  businessPremisesId String
  year               Int
  lastNumber         Int              @default(0)
  updatedAt          DateTime         @updatedAt
  businessPremises   BusinessPremises @relation(fields: [businessPremisesId], references: [id], onDelete: Cascade)
  company            Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([businessPremisesId, year])
  @@index([companyId])
}

model Expense {
  id                   String                @id @default(cuid())
  companyId            String
  vendorId             String?
  vendorOrganizationId String?
  categoryId           String
  description          String
  date                 DateTime
  dueDate              DateTime?
  netAmount            Decimal               @db.Decimal(10, 2)
  vatAmount            Decimal               @db.Decimal(10, 2)
  vatRate              Decimal               @db.Decimal(5, 2)
  totalAmount          Decimal               @db.Decimal(10, 2)
  vatDeductible        Boolean               @default(true)
  currency             String                @default("EUR")
  status               ExpenseStatus         @default(DRAFT)
  statusBeforeMatch    ExpenseStatus?
  paymentMethod        PaymentMethod?
  paymentDate          DateTime?
  receiptUrl           String?
  notes                String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  bankTransactions     BankTransaction[]
  lines                ExpenseLine[]
  supplierBill         SupplierBill?
  attachments          Attachment[]
  uraInputs            UraInput[]
  corrections          ExpenseCorrection[]
  assetCandidates      FixedAssetCandidate[]
  category             ExpenseCategory       @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  company              Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  vendor               Contact?              @relation("ExpenseVendor", fields: [vendorId], references: [id])
  vendorOrganization   Organization?         @relation("ExpenseVendorOrganization", fields: [vendorOrganizationId], references: [id])
  stockMovements       StockMovement[]
  matchRecords         MatchRecord[]

  @@index([companyId])
  @@index([date])
  @@index([status])
  @@index([categoryId])
  @@index([vendorOrganizationId])
}

model ExpenseLine {
  id             String               @id @default(cuid())
  companyId      String
  expenseId      String
  description    String
  quantity       Decimal              @db.Decimal(10, 2)
  unitPrice      Decimal              @db.Decimal(10, 2)
  netAmount      Decimal              @db.Decimal(10, 2)
  vatRate        Decimal              @db.Decimal(5, 2)
  vatAmount      Decimal              @db.Decimal(10, 2)
  totalAmount    Decimal              @db.Decimal(10, 2)
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  expense        Expense              @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  company        Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  attachments    Attachment[]
  uraInputs      UraInput[]
  assetCandidate FixedAssetCandidate?

  @@index([companyId])
  @@index([expenseId])
}

model SupplierBill {
  id              String    @id @default(cuid())
  companyId       String
  expenseId       String    @unique
  documentNumber  String?
  issueDate       DateTime
  dueDate         DateTime?
  vendorName      String?
  vendorVatNumber String?
  netAmount       Decimal   @db.Decimal(10, 2)
  vatAmount       Decimal   @db.Decimal(10, 2)
  totalAmount     Decimal   @db.Decimal(10, 2)
  currency        String    @default("EUR")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  expense         Expense   @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  company         Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([issueDate])
}

model UraInput {
  id                     String       @id @default(cuid())
  companyId              String
  expenseId              String
  expenseLineId          String
  date                   DateTime
  vendorName             String?
  vendorVatNumber        String?
  netAmount              Decimal      @db.Decimal(10, 2)
  vatRate                Decimal      @db.Decimal(5, 2)
  vatAmount              Decimal      @db.Decimal(10, 2)
  totalAmount            Decimal      @db.Decimal(10, 2)
  deductibleVatAmount    Decimal      @db.Decimal(10, 2)
  nonDeductibleVatAmount Decimal      @db.Decimal(10, 2)
  ruleReferences         Json?
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  expense                Expense      @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  expenseLine            ExpenseLine  @relation(fields: [expenseLineId], references: [id], onDelete: Cascade)
  company                Company      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  attachments            Attachment[]

  @@index([companyId])
  @@index([expenseId])
  @@index([expenseLineId])
}

model Attachment {
  id                String           @id @default(cuid())
  companyId         String
  expenseId         String?
  expenseLineId     String?
  uraInputId        String?
  fileName          String
  contentType       String
  url               String
  size              Int?
  sourceType        AttachmentSource @default(UPLOAD)
  sourceExternalId  String?
  isSourceImmutable Boolean          @default(false)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  expense           Expense?         @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  expenseLine       ExpenseLine?     @relation(fields: [expenseLineId], references: [id], onDelete: Cascade)
  uraInput          UraInput?        @relation(fields: [uraInputId], references: [id], onDelete: Cascade)
  company           Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([expenseId])
  @@index([expenseLineId])
  @@index([uraInputId])
}

enum DocumentStatus {
  PENDING
  PROCESSED
  REVIEWED
  REJECTED
}

model Document {
  id          String         @id @default(cuid())
  companyId   String
  name        String
  category    String // expense, invoice, contract, other
  status      DocumentStatus @default(PENDING)
  totalAmount Decimal?       @db.Decimal(10, 2)
  currency    String?        @default("EUR")
  mimeType    String?
  url         String?
  uploadedAt  DateTime       @default(now())
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  company     Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([category])
  @@index([status])
  @@index([uploadedAt])
}

model ExpenseCorrection {
  id        String   @id @default(cuid())
  companyId String
  expenseId String
  userId    String?
  reason    String?
  changes   Json
  createdAt DateTime @default(now())
  expense   Expense  @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([expenseId])
}

model FixedAssetCandidate {
  id             String                    @id @default(cuid())
  companyId      String
  expenseId      String
  expenseLineId  String                    @unique
  fixedAssetId   String?
  description    String
  amount         Decimal                   @db.Decimal(10, 2)
  currency       String                    @default("EUR")
  thresholdValue Decimal                   @db.Decimal(10, 2)
  status         FixedAssetCandidateStatus @default(PENDING)
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt
  reviewedAt     DateTime?
  expense        Expense                   @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  expenseLine    ExpenseLine               @relation(fields: [expenseLineId], references: [id], onDelete: Cascade)
  fixedAsset     FixedAsset?               @relation(fields: [fixedAssetId], references: [id], onDelete: SetNull)
  company        Company                   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([expenseId])
  @@index([fixedAssetId])
}

model ExpenseCategory {
  id                   String    @id @default(cuid())
  companyId            String?
  name                 String
  code                 String
  vatDeductibleDefault Boolean   @default(true)
  receiptRequired      Boolean   @default(false)
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  expenses             Expense[]
  company              Company?  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, code])
  @@index([companyId])
}

model RecurringExpense {
  id          String    @id @default(cuid())
  companyId   String
  vendorId    String?
  categoryId  String
  description String
  netAmount   Decimal   @db.Decimal(10, 2)
  vatAmount   Decimal   @db.Decimal(10, 2)
  vatRate     Decimal   @db.Decimal(5, 2)
  totalAmount Decimal   @db.Decimal(10, 2)
  frequency   Frequency
  nextDate    DateTime
  endDate     DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  company     Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([nextDate])
}

enum TravelOrderStatus {
  DRAFT
  APPROVED
  COMPLETED
  CANCELLED
}

enum TravelVehicleType {
  COMPANY_CAR
  PRIVATE_CAR
  PUBLIC_TRANSPORT
  PLANE
  OTHER
}

enum MileageLogSource {
  MANUAL
  IMPORTED
  DEVICE
}

model TravelOrder {
  id                   String            @id @default(cuid())
  companyId            String
  travelerUserId       String?
  orderNumber          String
  purpose              String
  origin               String?
  destination          String
  departureDate        DateTime
  returnDate           DateTime
  vehicleType          TravelVehicleType
  distanceKm           Decimal?          @db.Decimal(10, 2)
  perDiemDays          Decimal?          @db.Decimal(8, 2)
  perDiemRate          Decimal?          @db.Decimal(10, 2)
  perDiemAmount        Decimal?          @db.Decimal(12, 2)
  mileageRate          Decimal?          @db.Decimal(10, 2)
  mileageAmount        Decimal?          @db.Decimal(12, 2)
  totalAmount          Decimal           @db.Decimal(12, 2)
  currency             String            @default("EUR")
  perDiemRuleVersionId String? // Soft ref to regulatory.RuleVersion (PR#1306)
  mileageRuleVersionId String? // Soft ref to regulatory.RuleVersion (PR#1306)
  status               TravelOrderStatus @default(DRAFT)
  notes                String?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  company              Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  travelerUser         User?             @relation("TravelOrderTraveler", fields: [travelerUserId], references: [id], onDelete: SetNull)
  mileageLogs          MileageLog[]
  pdfs                 TravelPdf[]

  @@unique([companyId, orderNumber])
  @@index([companyId])
  @@index([travelerUserId])
  @@index([status])
  @@index([departureDate])
  @@index([returnDate])
}

model MileageLog {
  id             String            @id @default(cuid())
  companyId      String
  travelOrderId  String?
  travelerUserId String?
  logDate        DateTime
  origin         String?
  destination    String?
  purpose        String
  startOdometer  Decimal?          @db.Decimal(12, 2)
  endOdometer    Decimal?          @db.Decimal(12, 2)
  distanceKm     Decimal           @db.Decimal(10, 2)
  vehicleType    TravelVehicleType
  source         MileageLogSource  @default(MANUAL)
  notes          String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  company        Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  travelOrder    TravelOrder?      @relation(fields: [travelOrderId], references: [id], onDelete: SetNull)
  travelerUser   User?             @relation("MileageLogTraveler", fields: [travelerUserId], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([travelOrderId])
  @@index([travelerUserId])
  @@index([logDate])
}

model TravelPdf {
  id                String      @id @default(cuid())
  companyId         String
  travelOrderId     String
  version           Int         @default(1)
  fileName          String
  mimeType          String      @default("application/pdf")
  sizeBytes         Int
  r2Key             String
  sha256            String
  sourceSnapshot    Json
  isImmutable       Boolean     @default(true)
  lockedAt          DateTime    @default(now())
  generatedAt       DateTime    @default(now())
  generatedByUserId String?
  createdAt         DateTime    @default(now())
  company           Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  travelOrder       TravelOrder @relation(fields: [travelOrderId], references: [id], onDelete: Cascade)
  generatedByUser   User?       @relation("TravelPdfGeneratedBy", fields: [generatedByUserId], references: [id], onDelete: SetNull)

  @@unique([travelOrderId, version])
  @@index([companyId])
  @@index([travelOrderId])
  @@index([sha256])
}

model SavedReport {
  id        String         @id @default(cuid())
  companyId String
  userId    String
  name      String
  type      ReportType
  filters   Json
  schedule  ReportSchedule @default(NONE)
  emailTo   String[]
  createdAt DateTime       @default(now())
  lastRunAt DateTime?
  company   Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([type])
  @@index([userId])
}

model BankAccount {
  id                    String            @id @default(cuid())
  companyId             String
  name                  String
  iban                  String
  bankName              String
  currency              String            @default("EUR")
  currentBalance        Decimal           @db.Decimal(12, 2)
  lastSyncAt            DateTime?
  isDefault             Boolean           @default(false)
  organizationId        String?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  connectionExpiresAt   DateTime?
  connectionStatus      ConnectionStatus  @default(MANUAL)
  syncProvider          SyncProvider?
  syncProviderAccountId String?
  company               Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  organization          Organization?     @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  connection            BankConnection?
  statementImports      StatementImport[]
  transactions          BankTransaction[]
  importJobs            ImportJob[]
  statements            Statement[]

  @@unique([companyId, iban])
  @@index([companyId])
  @@index([connectionStatus])
  @@index([organizationId])
}

model BankTransaction {
  id                         String            @id @default(cuid())
  companyId                  String
  bankAccountId              String
  statementImportId          String?
  date                       DateTime
  description                String
  amount                     Decimal           @db.Decimal(12, 2)
  balance                    Decimal           @db.Decimal(12, 2)
  currency                   String            @default("EUR")
  reference                  String?
  counterpartyName           String?
  counterpartyIban           String?
  counterpartyOrganizationId String?
  matchedInvoiceId           String?
  matchedExpenseId           String?
  matchStatus                MatchStatus       @default(UNMATCHED)
  matchedAt                  DateTime?
  matchedBy                  String?
  createdAt                  DateTime          @default(now())
  confidenceScore            Int?
  externalId                 String?
  source                     TransactionSource @default(MANUAL)
  bankAccount                BankAccount       @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  statementImport            StatementImport?  @relation(fields: [statementImportId], references: [id], onDelete: SetNull)
  matchedExpense             Expense?          @relation(fields: [matchedExpenseId], references: [id], onDelete: SetNull)
  matchedInvoice             EInvoice?         @relation(fields: [matchedInvoiceId], references: [id], onDelete: SetNull)
  counterpartyOrganization   Organization?     @relation("BankTransactionCounterpartyOrganization", fields: [counterpartyOrganizationId], references: [id], onDelete: SetNull)
  matchRecords               MatchRecord[]
  unappliedPayment           UnappliedPayment?

  @@index([companyId])
  @@index([bankAccountId])
  @@index([matchStatus])
  @@index([date])
  @@index([externalId])
  @@index([statementImportId])
  @@index([counterpartyOrganizationId])
}

model MatchRecord {
  id                String          @id @default(cuid())
  companyId         String
  bankTransactionId String
  matchStatus       MatchStatus
  matchKind         MatchKind
  matchedInvoiceId  String?
  matchedExpenseId  String?
  confidenceScore   Int?
  reason            String?
  source            MatchSource     @default(MANUAL)
  metadata          Json?
  createdAt         DateTime        @default(now())
  createdBy         String?
  company           Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  bankTransaction   BankTransaction @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)
  matchedInvoice    EInvoice?       @relation(fields: [matchedInvoiceId], references: [id], onDelete: SetNull)
  matchedExpense    Expense?        @relation(fields: [matchedExpenseId], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([bankTransactionId])
  @@index([matchStatus])
  @@index([matchKind])
  @@index([createdAt])
}

model UnappliedPayment {
  id                String   @id @default(cuid())
  companyId         String
  bankTransactionId String   @unique
  amount            Decimal  @db.Decimal(12, 2)
  currency          String   @default("EUR")
  reason            String?
  createdAt         DateTime @default(now())

  company         Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  bankTransaction BankTransaction @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([createdAt])
}

model BankConnection {
  id                   String           @id @default(cuid())
  companyId            String
  bankAccountId        String           @unique
  provider             SyncProvider
  providerConnectionId String
  institutionId        String
  institutionName      String
  status               ConnectionStatus @default(MANUAL)
  authorizedAt         DateTime?
  expiresAt            DateTime?
  lastError            String?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  bankAccount          BankAccount      @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  company              Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([status])
  @@index([providerConnectionId])
}

model PotentialDuplicate {
  id              String               @id @default(cuid())
  companyId       String
  transactionAId  String
  transactionBId  String
  similarityScore Float
  reason          String
  status          DuplicateStatus      @default(PENDING)
  resolvedAt      DateTime?
  resolvedBy      String?
  resolution      DuplicateResolution?
  createdAt       DateTime             @default(now())
  company         Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([status])
}

model EmailConnection {
  id              String                @id @default(cuid())
  companyId       String
  provider        EmailProvider
  emailAddress    String
  status          EmailConnectionStatus @default(CONNECTED)
  accessTokenEnc  String?
  refreshTokenEnc String
  tokenExpiresAt  DateTime?
  scopes          String[]
  lastSyncAt      DateTime?
  syncCursor      String?
  lastError       String?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  attachments     EmailAttachment[]
  company         Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  importRules     EmailImportRule[]

  @@unique([companyId, emailAddress])
  @@index([companyId])
  @@index([status])
}

model EmailImportRule {
  id               String          @id @default(cuid())
  connectionId     String
  companyId        String
  senderEmail      String?
  senderDomain     String?
  subjectContains  String?
  filenameContains String?
  isActive         Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  company          Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  connection       EmailConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@index([companyId])
}

model EmailAttachment {
  id                   String           @id @default(cuid())
  companyId            String
  connectionId         String
  providerMessageId    String
  providerAttachmentId String?
  contentHash          String
  receivedAt           DateTime
  senderEmail          String
  subject              String
  filename             String
  mimeType             String
  sizeBytes            Int
  r2Key                String
  status               AttachmentStatus @default(PENDING)
  importJobId          String?          @unique
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  company              Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  connection           EmailConnection  @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  importJob            ImportJob?       @relation(fields: [importJobId], references: [id])

  @@unique([connectionId, contentHash])
  @@index([companyId])
  @@index([connectionId])
  @@index([status])
}

model StatementImport {
  id               String            @id @default(cuid())
  companyId        String
  bankAccountId    String
  importJobId      String?           @unique
  fileName         String
  fileChecksum     String
  format           ImportFormat
  transactionCount Int
  importedAt       DateTime          @default(now())
  importedBy       String
  metadata         Json?
  bankAccount      BankAccount       @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  company          Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  importJob        ImportJob?        @relation(fields: [importJobId], references: [id], onDelete: SetNull)
  transactions     BankTransaction[]

  @@unique([bankAccountId, fileChecksum])
  @@index([companyId])
  @@index([bankAccountId])
  @@index([importJobId])
}

model ImportJob {
  id              String           @id @default(cuid())
  companyId       String
  userId          String
  bankAccountId   String?
  fileChecksum    String
  originalName    String
  storagePath     String?
  storageKey      String?
  status          JobStatus        @default(PENDING)
  tierUsed        TierType?
  failureReason   String?
  pagesProcessed  Int              @default(0)
  pagesFailed     Int              @default(0)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  documentType    DocumentType?
  extractedData   Json?
  invoice         EInvoice?
  emailAttachment EmailAttachment?
  bankAccount     BankAccount?     @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  company         Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  statement       Statement?
  statementImport StatementImport?

  @@index([companyId])
  @@index([bankAccountId])
  @@index([status])
  @@index([userId])
  @@index([bankAccountId, fileChecksum])
}

model Statement {
  id                  String          @id @default(cuid())
  importJobId         String          @unique
  companyId           String
  bankAccountId       String
  statementDate       DateTime
  periodStart         DateTime
  periodEnd           DateTime
  sequenceNumber      Int
  previousStatementId String?
  openingBalance      Decimal         @db.Decimal(14, 2)
  closingBalance      Decimal         @db.Decimal(14, 2)
  currency            String          @default("EUR")
  isGapDetected       Boolean         @default(false)
  isLocked            Boolean         @default(false)
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  bankAccount         BankAccount     @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  company             Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  importJob           ImportJob       @relation(fields: [importJobId], references: [id], onDelete: Cascade)
  previousStatement   Statement?      @relation("StatementChain", fields: [previousStatementId], references: [id])
  nextStatements      Statement[]     @relation("StatementChain")
  pages               StatementPage[]
  transactions        Transaction[]

  @@unique([bankAccountId, sequenceNumber, periodStart])
  @@index([companyId])
  @@index([bankAccountId])
  @@index([periodStart])
}

model StatementPage {
  id               String        @id @default(cuid())
  statementId      String
  companyId        String
  pageNumber       Int
  pageStartBalance Decimal?      @db.Decimal(14, 2)
  pageEndBalance   Decimal?      @db.Decimal(14, 2)
  status           PageStatus    @default(PENDING)
  rawText          String?
  company          Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  statement        Statement     @relation(fields: [statementId], references: [id], onDelete: Cascade)
  transactions     Transaction[]

  @@unique([statementId, pageNumber])
  @@index([companyId])
}

model Transaction {
  id          String        @id @default(cuid())
  statementId String
  pageId      String
  companyId   String
  date        DateTime
  amount      Decimal       @db.Decimal(14, 2)
  direction   TxDirection
  payeeName   String?
  description String?
  reference   String?
  iban        String?
  category    String?
  company     Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  page        StatementPage @relation(fields: [pageId], references: [id], onDelete: Cascade)
  statement   Statement     @relation(fields: [statementId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([statementId])
  @@index([pageId])
  @@index([date])
}

model SupportTicket {
  id           String                 @id @default(cuid())
  companyId    String
  createdById  String?
  assignedToId String?
  title        String
  body         String?
  status       SupportTicketStatus    @default(OPEN)
  priority     SupportTicketPriority  @default(NORMAL)
  slaDeadline  DateTime?
  escalatedAt  DateTime?
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  category     TicketCategory         @default(GENERAL)
  company      Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdBy    User?                  @relation("SupportTicketCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  assignedTo   User?                  @relation("SupportTicketAssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)
  messages     SupportTicketMessage[]

  @@index([companyId])
  @@index([status])
  @@index([priority])
  @@index([createdById])
  @@index([assignedToId])
  @@index([slaDeadline])
}

model SupportTicketMessage {
  id          String                    @id @default(cuid())
  ticketId    String
  authorId    String?
  body        String
  createdAt   DateTime                  @default(now())
  ticket      SupportTicket             @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  attachments SupportTicketAttachment[]

  @@index([ticketId])
}

model SupportTicketAttachment {
  id        String               @id @default(cuid())
  messageId String
  fileName  String
  fileType  String
  fileSize  Int
  r2Key     String
  createdAt DateTime             @default(now())
  message   SupportTicketMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
}

model WebAuthnCredential {
  id           String    @id @default(cuid())
  userId       String
  credentialId String    @unique
  publicKey    String
  counter      BigInt    @default(0)
  transports   String?
  name         String?
  createdAt    DateTime  @default(now())
  lastUsedAt   DateTime?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model FiscalCertificate {
  id                        String          @id @default(cuid())
  companyId                 String
  environment               FiscalEnv
  provider                  String          @default("DIRECT")
  certSubject               String
  certSerial                String
  certNotBefore             DateTime
  certNotAfter              DateTime
  oibExtracted              String
  certSha256                String
  encryptedP12              String
  encryptedDataKey          String
  status                    CertStatus      @default(PENDING)
  lastUsedAt                DateTime?
  lastExpiryNotificationAt  DateTime? // When last expiry notification was sent
  lastExpiryNotificationDay Int? // Days remaining when notification was sent (30, 14, 7, 1)
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt
  company                   Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  fiscalRequests            FiscalRequest[]

  @@unique([companyId, environment])
  @@index([companyId])
  @@index([status])
}

/// Tenant-owned integration identity with encrypted secrets
/// All regulated actions MUST resolve through this model
model IntegrationAccount {
  id            String   @id @default(cuid())
  companyId     String
  company       Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Integration identity
  kind          IntegrationKind
  environment   IntegrationEnv   @default(PROD)
  status        IntegrationStatus @default(ACTIVE)

  // Provider configuration (non-sensitive JSON)
  providerConfig Json?

  // Encrypted secrets (unified vault)
  // Format: envelope-encrypted JSON payload
  secretEnvelope    String?
  secretKeyVersion  Int      @default(1)

  // Audit fields
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  rotatedAt     DateTime?
  lastUsedAt    DateTime?

  // Relations
  eInvoices          EInvoice[]
  providerSyncStates ProviderSyncState[]
  fiscalRequests     FiscalRequest[]

  // Constraints
  @@unique([companyId, kind, environment], map: "integration_account_company_kind_env_key")
  @@index([companyId], map: "integration_account_company_idx")
  @@index([status], map: "integration_account_status_idx")
  @@map("integration_account")
}

// Certificate expiry notification tracking with retry support
model CertificateNotification {
  id              String                        @id @default(cuid())
  certificateId   String
  companyId       String
  notificationDay Int // Days before expiry (30, 14, 7, 1)
  status          CertificateNotificationStatus @default(PENDING)
  attemptCount    Int                           @default(0)
  maxAttempts     Int                           @default(3)
  nextRetryAt     DateTime?
  error           String?
  sentAt          DateTime?
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt

  @@unique([certificateId, notificationDay])
  @@index([status, nextRetryAt])
  @@index([companyId])
}

model FiscalRequest {
  id                   String            @id @default(cuid())
  companyId            String
  certificateId        String? // Optional: null when cert-missing failure
  invoiceId            String?
  integrationAccountId String? // IntegrationAccount used for signing (Phase 4+)
  messageType          FiscalMessageType
  status               FiscalStatus      @default(QUEUED)
  attemptCount         Int               @default(0)
  maxAttempts          Int               @default(5)
  nextRetryAt          DateTime          @default(now())
  lockedAt             DateTime?
  lockedBy             String?
  jir                  String?
  zki                  String?
  certificateSubject   String?
  certificateSerial    String?
  certificateNotBefore DateTime?
  certificateNotAfter  DateTime?
  certificateSha256    String?
  certificateProvider  String?
  certificateOib       String?
  qrInvoiceNumber      String?
  qrIssuerOib          String?
  qrIssueDate          DateTime?
  qrAmount             Decimal?          @db.Decimal(10, 2)
  errorCode            String?
  errorMessage         String?
  lastHttpStatus       Int?
  requestXml           String?
  signedXml            String?
  responseXml          String?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  certificate          FiscalCertificate? @relation(fields: [certificateId], references: [id], onDelete: Restrict)
  company              Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invoice              EInvoice?         @relation(fields: [invoiceId], references: [id], onDelete: SetNull)
  integrationAccount   IntegrationAccount? @relation(fields: [integrationAccountId], references: [id], onDelete: Restrict)
  responses            FiscalResponse[]

  @@unique([companyId, invoiceId, messageType])
  @@index([status, nextRetryAt])
  @@index([companyId])
  @@index([invoiceId])
  @@index([integrationAccountId])
}

model FiscalResponse {
  id                String               @id @default(cuid())
  requestId         String
  status            FiscalResponseStatus
  attemptNumber     Int
  jir               String?
  zki               String?
  responseXml       String?
  errorCode         String?
  errorMessage      String?
  httpStatus        Int?
  qrJir             String?
  qrZki             String?
  qrVerificationUrl String?
  qrDateTime        DateTime?
  qrAmount          Decimal?             @db.Decimal(10, 2)
  createdAt         DateTime             @default(now())
  request           FiscalRequest        @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([requestId])
  @@index([status])
}

model AIFeedback {
  id         String   @id @default(cuid())
  companyId  String
  userId     String
  entityType String
  entityId   String
  operation  String
  feedback   String
  correction Json?
  notes      String?
  createdAt  DateTime @default(now())

  @@index([companyId])
  @@index([entityType, entityId])
  @@index([operation])
  @@index([userId])
}

model AIUsage {
  id         String   @id @default(cuid())
  companyId  String
  userId     String?
  operation  String
  tokensUsed Int?
  costCents  Int?
  model      String?
  success    Boolean  @default(true)
  durationMs Int?     // API call latency in milliseconds
  provider   String?  // "openai" | "deepseek" | "ollama"
  createdAt  DateTime @default(now())
  company    Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId, createdAt])
  @@index([companyId, operation])
  @@index([userId, createdAt])
  @@index([provider, createdAt])
}

model ArticleJob {
  id               String         @id @default(cuid())
  type             ArticleType
  status           ArticleStatus  @default(SYNTHESIZING)
  sourceUrls       String[]
  topic            String?
  currentIteration Int            @default(0)
  maxIterations    Int            @default(3)
  factSheetId      String?        @unique
  finalContentMdx  String?
  finalSlug        String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  publishedAt      DateTime?
  drafts           ArticleDraft[]
  factSheet        FactSheet?

  @@index([status])
  @@index([type])
}

model FactSheet {
  id           String        @id @default(cuid())
  jobId        String        @unique
  topic        String
  keyEntities  Json
  createdAt    DateTime      @default(now())
  claims       Claim[]
  job          ArticleJob    @relation(fields: [jobId], references: [id], onDelete: Cascade)
  sourceChunks SourceChunk[]
}

model Claim {
  id            String              @id @default(cuid())
  factSheetId   String
  statement     String
  quote         String?
  sourceUrl     String
  sourceChunkId String?
  confidence    Float
  category      String?
  factSheet     FactSheet           @relation(fields: [factSheetId], references: [id], onDelete: Cascade)
  sourceChunk   SourceChunk?        @relation(fields: [sourceChunkId], references: [id], onDelete: SetNull)
  verifications ClaimVerification[]

  @@index([factSheetId])
  @@index([sourceChunkId])
}

model SourceChunk {
  id          String    @id @default(cuid())
  factSheetId String
  sourceUrl   String
  content     String
  fetchedAt   DateTime  @default(now())
  claims      Claim[]
  factSheet   FactSheet @relation(fields: [factSheetId], references: [id], onDelete: Cascade)

  @@index([factSheetId])
}

model ArticleDraft {
  id         String           @id @default(cuid())
  jobId      String
  iteration  Int
  contentMdx String
  createdAt  DateTime         @default(now())
  job        ArticleJob       @relation(fields: [jobId], references: [id], onDelete: Cascade)
  paragraphs DraftParagraph[]

  @@unique([jobId, iteration])
}

model DraftParagraph {
  id                 String              @id @default(cuid())
  draftId            String
  index              Int
  content            String
  isLocked           Boolean             @default(false)
  confidence         Float?
  supportingClaimIds String[]
  verifications      ClaimVerification[]
  draft              ArticleDraft        @relation(fields: [draftId], references: [id], onDelete: Cascade)

  @@unique([draftId, index])
}

model ClaimVerification {
  id              String         @id @default(cuid())
  paragraphId     String
  claimId         String
  similarityScore Float
  isSupporting    Boolean
  createdAt       DateTime       @default(now())
  claim           Claim          @relation(fields: [claimId], references: [id], onDelete: Cascade)
  paragraph       DraftParagraph @relation(fields: [paragraphId], references: [id], onDelete: Cascade)

  @@unique([paragraphId, claimId])
}






model Payout {
  id                 String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId          String                @map("company_id")
  payoutDate         DateTime              @map("payout_date") @db.Date
  periodYear         Int                   @map("period_year")
  periodMonth        Int                   @map("period_month")
  periodFrom         DateTime              @map("period_from") @db.Date
  periodTo           DateTime              @map("period_to") @db.Date
  currency           String                @default("EUR") @map("currency") @db.VarChar(3)
  description        String?               @map("description") @db.VarChar(255)
  status             PayoutStatus          @default(DRAFT)
  lockedAt           DateTime?             @map("locked_at") @db.Timestamp(6)
  lockedById         String?               @map("locked_by_id")
  reportedAt         DateTime?             @map("reported_at") @db.Timestamp(6)
  reportedById       String?               @map("reported_by_id")
  createdAt          DateTime?             @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt          DateTime?             @updatedAt @map("updated_at") @db.Timestamp(6)
  company            Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  lockedBy           User?                 @relation("PayoutLockedBy", fields: [lockedById], references: [id], onDelete: SetNull)
  reportedBy         User?                 @relation("PayoutReportedBy", fields: [reportedById], references: [id], onDelete: SetNull)
  lines              PayoutLine[]
  payslips           Payslip[]
  payslipArtifacts   PayslipArtifact[]
  snapshots          CalculationSnapshot[]
  bankPaymentExports BankPaymentExport[]

  @@index([companyId, periodYear, periodMonth], map: "payout_period_idx")
  @@index([companyId, status], map: "payout_status_idx")
  @@map("payout")
}

model PayoutLine {
  id                    String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId             String                @map("company_id")
  payoutId              String                @map("payout_id") @db.Uuid
  employeeId            String?               @map("employee_id")
  lineNumber            Int                   @map("line_number")
  employeeName          String?               @map("employee_name") @db.VarChar(200)
  employeeOib           String?               @map("employee_oib") @db.VarChar(11)
  employeeIban          String?               @map("employee_iban") @db.VarChar(34)
  recipientName         String?               @map("recipient_name") @db.VarChar(200)
  recipientOib          String?               @map("recipient_oib") @db.VarChar(11)
  grossAmount           Decimal?              @map("gross_amount") @db.Decimal(12, 2)
  netAmount             Decimal?              @map("net_amount") @db.Decimal(12, 2)
  taxAmount             Decimal?              @map("tax_amount") @db.Decimal(12, 2)
  currency              String                @default("EUR") @map("currency") @db.VarChar(3)
  joppdData             Json?                 @map("joppd_data")
  ruleVersionId         String?               @map("rule_version_id")
  appliedRuleSnapshotId String?               @map("applied_rule_snapshot_id")
  createdAt             DateTime?             @default(now()) @map("created_at") @db.Timestamp(6)
  payout                Payout                @relation(fields: [payoutId], references: [id], onDelete: Cascade)
  // ruleVersionId is now a soft reference only - relation removed in PR#9
  // Use AppliedRuleSnapshot for rule data access
  appliedRuleSnapshot   AppliedRuleSnapshot?  @relation(fields: [appliedRuleSnapshotId], references: [id], onDelete: SetNull)
  company               Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee              Employee?             @relation(fields: [employeeId], references: [id], onDelete: SetNull)
  submissions           JoppdSubmissionLine[]
  payslips              Payslip[]
  snapshots             CalculationSnapshot[]
  bankPaymentLines      BankPaymentLine[]
  payslipArtifacts      PayslipArtifact[]

  @@index([companyId], map: "payout_line_company_idx")
  @@index([payoutId], map: "payout_line_payout_idx")
  @@index([ruleVersionId], map: "payout_line_rule_version_idx")
  @@index([appliedRuleSnapshotId], map: "payout_line_snapshot_idx")
  @@index([employeeId], map: "payout_line_employee_idx")
  @@map("payout_line")
}

model Payslip {
  id                    String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId             String               @map("company_id")
  payoutId              String               @map("payout_id") @db.Uuid
  payoutLineId          String               @map("payout_line_id") @db.Uuid
  employeeId            String?              @map("employee_id")
  employeeName          String?              @map("employee_name") @db.VarChar(200)
  employeeOib           String?              @map("employee_oib") @db.VarChar(11)
  employeeIban          String?              @map("employee_iban") @db.VarChar(34)
  currency              String               @default("EUR") @map("currency") @db.VarChar(3)
  grossAmount           Decimal?             @map("gross_amount") @db.Decimal(12, 2)
  netAmount             Decimal?             @map("net_amount") @db.Decimal(12, 2)
  taxAmount             Decimal?             @map("tax_amount") @db.Decimal(12, 2)
  calculationSnapshotId String?              @map("calculation_snapshot_id") @db.Uuid
  issuedAt              DateTime?            @map("issued_at") @db.Date
  createdAt             DateTime?            @default(now()) @map("created_at") @db.Timestamp(6)
  payout                Payout               @relation(fields: [payoutId], references: [id], onDelete: Cascade)
  payoutLine            PayoutLine           @relation(fields: [payoutLineId], references: [id], onDelete: Cascade)
  company               Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee              Employee?            @relation(fields: [employeeId], references: [id], onDelete: SetNull)
  calculationSnapshot   CalculationSnapshot? @relation(fields: [calculationSnapshotId], references: [id], onDelete: SetNull)
  artifacts             PayslipArtifact[]

  @@index([companyId], map: "payslip_company_idx")
  @@index([payoutId], map: "payslip_payout_idx")
  @@index([payoutLineId], map: "payslip_line_idx")
  @@index([employeeId], map: "payslip_employee_idx")
  @@map("payslip")
}

model PayslipArtifact {
  id           String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId    String      @map("company_id")
  payoutId     String      @map("payout_id") @db.Uuid
  payoutLineId String?     @map("payout_line_id") @db.Uuid
  payslipId    String?     @map("payslip_id") @db.Uuid
  storageKey   String      @map("storage_key") @db.VarChar(500)
  fileHash     String?     @map("file_hash") @db.VarChar(64)
  fileName     String?     @map("file_name") @db.VarChar(255)
  contentType  String?     @map("content_type") @db.VarChar(100)
  createdAt    DateTime?   @default(now()) @map("created_at") @db.Timestamp(6)
  createdById  String?     @map("created_by_id")
  payout       Payout      @relation(fields: [payoutId], references: [id], onDelete: Cascade)
  payoutLine   PayoutLine? @relation(fields: [payoutLineId], references: [id], onDelete: SetNull)
  payslip      Payslip?    @relation(fields: [payslipId], references: [id], onDelete: SetNull)
  company      Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdBy    User?       @relation("PayslipArtifactCreator", fields: [createdById], references: [id], onDelete: SetNull)

  @@index([companyId], map: "payslip_artifact_company_idx")
  @@index([payoutId], map: "payslip_artifact_payout_idx")
  @@index([payoutLineId], map: "payslip_artifact_line_idx")
  @@index([payslipId], map: "payslip_artifact_payslip_idx")
  @@map("payslip_artifact")
}

model CalculationSnapshot {
  id                  String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId           String      @map("company_id")
  payoutId            String      @map("payout_id") @db.Uuid
  payoutLineId        String?     @map("payout_line_id") @db.Uuid
  rulesEngineSnapshot Json        @map("rules_engine_snapshot")
  employmentSnapshot  Json        @map("employment_snapshot")
  inputSnapshot       Json        @map("input_snapshot")
  outputSnapshot      Json        @map("output_snapshot")
  createdAt           DateTime?   @default(now()) @map("created_at") @db.Timestamp(6)
  createdById         String?     @map("created_by_id")
  company             Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  payout              Payout      @relation(fields: [payoutId], references: [id], onDelete: Cascade)
  payoutLine          PayoutLine? @relation(fields: [payoutLineId], references: [id], onDelete: SetNull)
  createdBy           User?       @relation("CalculationSnapshotCreator", fields: [createdById], references: [id], onDelete: SetNull)
  payslips            Payslip[]

  @@index([companyId], map: "calculation_snapshot_company_idx")
  @@index([payoutId], map: "calculation_snapshot_payout_idx")
  @@index([payoutLineId], map: "calculation_snapshot_line_idx")
  @@map("calculation_snapshot")
}

// =============================================================================
// APPLIED RULE SNAPSHOT - Immutable record of regulatory rule at time of use
// =============================================================================
// When a PayoutLine or JoppdSubmissionLine is created, we snapshot the exact
// rule version that was applied. This decouples core transactional records
// from the regulatory DB while preserving audit trail.
//
// Key invariants:
// - Immutable once created (no updates allowed - enforced by Prisma extension)
// - ruleVersionId is a soft ref to regulatory DB (no FK constraint)
// - companyId for tenant isolation (auto-injected by TENANT_MODELS extension)
// - dataHash for deduplication within a tenant
//
// CREATION CONTRACT:
// All snapshot creation MUST go through getOrCreateAppliedRuleSnapshot()
// in src/lib/rules/applied-rule-snapshot-service.ts. Direct db.appliedRuleSnapshot.create()
// is prohibited outside that service.
//
// effectiveFrom SEMANTICS:
// This is a DATE-ONLY field representing the legal effective date of the rule
// in Croatian regulatory context. It is NOT a timestamp. All DateTime values
// are truncated to midnight UTC in the service layer. This matches how Croatian
// tax regulations specify effective dates (e.g., "od 1. sijenja 2025.")

model AppliedRuleSnapshot {
  id            String   @id @default(cuid())
  companyId     String   @map("company_id")
  ruleVersionId String   @map("rule_version_id") // Soft ref to RuleVersion in regulatory DB
  ruleTableKey  String   @map("rule_table_key") @db.VarChar(100) // e.g., "pausalni-doprinos-2025"
  version       String   @db.VarChar(50) // e.g., "v1.0.0" or "2025-01-01"
  effectiveFrom DateTime @map("effective_from") @db.Date // Legal date, NOT timestamp
  dataHash      String   @map("data_hash") @db.VarChar(64) // SHA-256 of snapshotData for dedupe
  snapshotData  Json     @map("snapshot_data") // Complete rule data at time of snapshot
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamp(6)

  company              Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  payoutLines          PayoutLine[]
  joppdSubmissionLines JoppdSubmissionLine[]

  @@unique([companyId, ruleVersionId, dataHash], map: "applied_rule_snapshot_dedupe_idx")
  @@index([companyId, ruleTableKey, effectiveFrom], map: "applied_rule_snapshot_lookup_idx")
  @@index([companyId, dataHash], map: "applied_rule_snapshot_hash_idx")
  @@map("applied_rule_snapshot")
}

model BankPaymentExport {
  id           String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId    String            @map("company_id")
  payoutId     String            @map("payout_id") @db.Uuid
  format       String            @default("SEPA_CT") @map("format") @db.VarChar(50)
  createdAt    DateTime?         @default(now()) @map("created_at") @db.Timestamp(6)
  createdById  String?           @map("created_by_id")
  exportedAt   DateTime?         @map("exported_at") @db.Timestamp(6)
  exportedById String?           @map("exported_by_id")
  payout       Payout            @relation(fields: [payoutId], references: [id], onDelete: Cascade)
  company      Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdBy    User?             @relation("BankPaymentExportCreator", fields: [createdById], references: [id], onDelete: SetNull)
  exportedBy   User?             @relation("BankPaymentExportExporter", fields: [exportedById], references: [id], onDelete: SetNull)
  lines        BankPaymentLine[]

  @@index([companyId], map: "bank_payment_export_company_idx")
  @@index([payoutId], map: "bank_payment_export_payout_idx")
  @@map("bank_payment_export")
}

model BankPaymentLine {
  id                    String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId             String               @map("company_id")
  exportId              String               @map("export_id") @db.Uuid
  payoutLineId          String               @map("payout_line_id") @db.Uuid
  joppdSubmissionLineId String?              @map("joppd_submission_line_id") @db.Uuid
  recipientName         String               @map("recipient_name") @db.VarChar(200)
  recipientIban         String?              @map("recipient_iban") @db.VarChar(34)
  amount                Decimal              @map("amount") @db.Decimal(12, 2)
  currency              String               @default("EUR") @map("currency") @db.VarChar(3)
  reference             String?              @map("reference") @db.VarChar(50)
  description           String?              @map("description") @db.VarChar(255)
  createdAt             DateTime?            @default(now()) @map("created_at") @db.Timestamp(6)
  export                BankPaymentExport    @relation(fields: [exportId], references: [id], onDelete: Cascade)
  payoutLine            PayoutLine           @relation(fields: [payoutLineId], references: [id], onDelete: Restrict)
  joppdSubmissionLine   JoppdSubmissionLine? @relation(fields: [joppdSubmissionLineId], references: [id], onDelete: SetNull)
  company               Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId], map: "bank_payment_line_company_idx")
  @@index([exportId], map: "bank_payment_line_export_idx")
  @@index([payoutLineId], map: "bank_payment_line_payout_idx")
  @@index([joppdSubmissionLineId], map: "bank_payment_line_joppd_idx")
  @@map("bank_payment_line")
}

model JoppdSubmission {
  id                    String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId             String                 @map("company_id")
  periodYear            Int                    @map("period_year")
  periodMonth           Int                    @map("period_month")
  status                JoppdSubmissionStatus  @default(PREPARED)
  submissionReference   String?                @map("submission_reference") @db.VarChar(100)
  isCorrection          Boolean                @default(false) @map("is_correction")
  correctedSubmissionId String?                @map("corrected_submission_id") @db.Uuid
  signedXmlStorageKey   String?                @map("signed_xml_storage_key") @db.VarChar(500)
  signedXmlHash         String?                @map("signed_xml_hash") @db.VarChar(64)
  createdAt             DateTime?              @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt             DateTime?              @updatedAt @map("updated_at") @db.Timestamp(6)
  submittedAt           DateTime?              @map("submitted_at") @db.Timestamp(6)
  acceptedAt            DateTime?              @map("accepted_at") @db.Timestamp(6)
  rejectedAt            DateTime?              @map("rejected_at") @db.Timestamp(6)
  rejectionReason       String?                @map("rejection_reason") @db.VarChar(500)
  company               Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  correctedSubmission   JoppdSubmission?       @relation("JoppdSubmissionCorrections", fields: [correctedSubmissionId], references: [id], onDelete: SetNull)
  corrections           JoppdSubmission[]      @relation("JoppdSubmissionCorrections")
  lines                 JoppdSubmissionLine[]
  events                JoppdSubmissionEvent[]

  @@index([companyId, periodYear, periodMonth], map: "joppd_submission_period_idx")
  @@index([status], map: "joppd_submission_status_idx")
  @@map("joppd_submission")
}

model JoppdSubmissionLine {
  id                    String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  submissionId          String                @map("submission_id") @db.Uuid
  payoutLineId          String                @map("payout_line_id") @db.Uuid
  lineNumber            Int                   @map("line_number")
  lineData              Json?                 @map("line_data")
  originalLineId        String?               @map("original_line_id") @db.Uuid
  ruleVersionId         String?               @map("rule_version_id")
  appliedRuleSnapshotId String?               @map("applied_rule_snapshot_id")
  createdAt             DateTime?             @default(now()) @map("created_at") @db.Timestamp(6)
  submission            JoppdSubmission       @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  payoutLine            PayoutLine            @relation(fields: [payoutLineId], references: [id], onDelete: Restrict)
  // ruleVersionId is now a soft reference only - relation removed in PR#9
  // Use AppliedRuleSnapshot for rule data access
  appliedRuleSnapshot   AppliedRuleSnapshot?  @relation(fields: [appliedRuleSnapshotId], references: [id], onDelete: SetNull)
  originalLine          JoppdSubmissionLine?  @relation("JoppdLineCorrections", fields: [originalLineId], references: [id], onDelete: SetNull)
  corrections           JoppdSubmissionLine[] @relation("JoppdLineCorrections")
  bankPaymentLines      BankPaymentLine[]

  @@index([submissionId], map: "joppd_submission_line_submission_idx")
  @@index([payoutLineId], map: "joppd_submission_line_payout_idx")
  @@index([ruleVersionId], map: "joppd_submission_line_rule_version_idx")
  @@index([appliedRuleSnapshotId], map: "joppd_submission_line_snapshot_idx")
  @@map("joppd_submission_line")
}

model JoppdSubmissionEvent {
  id           String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  submissionId String                @map("submission_id") @db.Uuid
  status       JoppdSubmissionStatus
  note         String?               @db.VarChar(500)
  createdAt    DateTime?             @default(now()) @map("created_at") @db.Timestamp(6)
  submission   JoppdSubmission       @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@index([submissionId], map: "joppd_submission_event_submission_idx")
  @@index([status], map: "joppd_submission_event_status_idx")
  @@map("joppd_submission_event")
}












enum VerificationCodeType {
  EMAIL_VERIFY
  PASSWORD_RESET
  LOGIN_VERIFY
}

enum Role {
  OWNER
  ADMIN
  MEMBER
  ACCOUNTANT
  VIEWER
}

enum SystemRole {
  USER
  STAFF
  ADMIN
}

enum EmploymentContractStatus {
  ACTIVE
  TERMINATED
  SUSPENDED
}

enum EmploymentType {
  FULL_TIME
  PART_TIME
  FIXED_TERM
  TEMPORARY
  CONTRACTOR
}

enum TerminationReason {
  RESIGNATION
  DISMISSAL
  END_OF_CONTRACT
  RETIREMENT
  MUTUAL_AGREEMENT
  OTHER
}

enum DependentRelation {
  CHILD
  SPOUSE
  PARENT
  OTHER
}

enum AllowanceType {
  MEAL
  TRANSPORT
  HOUSING
  BONUS
  OTHER
}

enum PensionPillarType {
  FIRST
  SECOND
  THIRD
}

enum ClientInvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum StaffReviewEntity {
  EINVOICE
  EXPENSE
  DOCUMENT
}

enum TicketCategory {
  TECHNICAL
  BILLING
  ACCOUNTING
  GENERAL
}

enum ContactType {
  CUSTOMER
  SUPPLIER
  BOTH
}

enum TaxIdentityType {
  OIB
  VAT
}

enum PersonSnapshotAction {
  CREATE
  UPDATE
  DELETE
}

enum PersonEventType {
  PERSON_CREATED
  PERSON_UPDATED
  PERSON_DELETED
  CONTACT_ROLE_ASSIGNED
  EMPLOYEE_ROLE_ASSIGNED
  DIRECTOR_ROLE_ASSIGNED
  CONTACT_ROLE_REMOVED
  EMPLOYEE_ROLE_REMOVED
  DIRECTOR_ROLE_REMOVED
}

enum EInvoiceDirection {
  OUTBOUND
  INBOUND
}

enum EInvoiceStatus {
  DRAFT
  PENDING_FISCALIZATION
  FISCALIZED
  SENT
  DELIVERED
  ACCEPTED
  REJECTED
  ARCHIVED
  ERROR
}

enum InvoicePaymentStatus {
  UNPAID
  PARTIAL
  PAID
}

enum InvoiceType {
  INVOICE
  E_INVOICE
  QUOTE
  PROFORMA
  CREDIT_NOTE
  DEBIT_NOTE
}

enum InvoiceEventType {
  REVENUE_REGISTERED
  FISCALIZATION_TRIGGERED
}

enum AccountNormalBalance {
  DEBIT
  CREDIT
}

enum StatementType {
  BALANCE_SHEET
  PROFIT_LOSS
}

enum AccountLockLevel {
  SYSTEM
  TEMPLATE
  USER
}

enum EntryStatus {
  DRAFT
  POSTED
}

enum PeriodType {
  MONTHLY
  QUARTERLY
  ANNUAL
}

enum PeriodStatus {
  FUTURE
  OPEN
  SOFT_CLOSE
  CLOSED
  LOCKED
}

enum ReportType {
  VAT
  PDV
  KPR
  PROFIT_LOSS
  BALANCE_SHEET
  VAT_SUMMARY
  REVENUE_BY_CUSTOMER
  EXPENSES_BY_CATEGORY
  RECEIVABLES_AGING
  PAYABLES_AGING
  CASH_FLOW
}

enum ReportingState {
  DRAFT
  READY_FOR_REVIEW
  APPROVED
  SUBMITTED
  REJECTED
}

enum ReviewQueueStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

enum ReviewQueuePriority {
  LOW
  NORMAL
  HIGH
}

enum ReviewQueueEntityType {
  REPORTING_STATUS
  ACCOUNTING_PERIOD
}

enum ReviewDecisionType {
  APPROVED
  REJECTED
}

enum OperationalSourceType {
  INVOICE
  EXPENSE
  BANK_TRANSACTION
  PAYROLL
  ASSET
  INVENTORY
}

enum OperationalEventType {
  INVOICE_ISSUED
  EXPENSE_RECORDED
  BANK_TRANSACTION_INCOMING
  BANK_TRANSACTION_OUTGOING
  PAYROLL_POSTED
  ASSET_ACQUIRED
  ASSET_DEPRECIATION
  ASSET_DISPOSED
  INVENTORY_RECEIPT
  INVENTORY_ISSUE
  INVENTORY_ADJUSTMENT
}

enum OperationalEventStatus {
  PENDING
  POSTED
  FAILED
}

enum ExportTargetSystem {
  SYNESIS
  PANTHEON
  MINIMAX
}

enum EntitlementChangeType {
  MODULE_ENABLED
  MODULE_DISABLED
  PERMISSIONS_UPDATED
  TRIAL_STARTED
  TRIAL_EXPIRED
  PLAN_UPGRADED
  PLAN_DOWNGRADED
  ENTITLEMENTS_MIGRATED
  MANUAL_OVERRIDE
}

enum AuditAction {
  // Core CRUD operations
  CREATE
  UPDATE
  DELETE
  VIEW
  EXPORT
  LOGIN
  LOGOUT

  // Regulatory Truth Layer - Evidence
  EVIDENCE_FETCHED
  EVIDENCE_HASH_REPAIRED

  // Regulatory Truth Layer - Rules
  RULE_CREATED
  RULE_APPROVED
  RULE_PUBLISHED
  RULE_AUTO_PUBLISHED
  RULE_REJECTED
  RULE_REJECTED_TEST_DATA
  RULE_DELETED
  RULE_MERGED
  RULE_ROLLBACK
  RULE_REVOKED
  RULE_QUEUED_FOR_REVIEW
  RULE_CONCEPT_LINKED
  MERGE_RULES

  // Regulatory Truth Layer - Concepts
  CONCEPT_CREATED
  CONCEPT_MERGED
  CONFIDENCE_DECAY_APPLIED

  // Regulatory Truth Layer - Conflicts
  CONFLICT_CREATED
  CONFLICT_RESOLVED
  CONFLICT_ESCALATED

  // Regulatory Truth Layer - Releases
  RELEASE_PUBLISHED
  RELEASE_ROLLED_BACK
  RELEASE_HASH_REPAIRED

  // Regulatory Truth Layer - Status Transitions & Pipeline
  RULE_STATUS_CHANGED
  PIPELINE_STAGE_COMPLETE

  // Staff Portal - Client Data Access (GDPR compliance)
  STAFF_VIEW_CLIENT
  STAFF_VIEW_INVOICES
  STAFF_VIEW_DOCUMENTS
  STAFF_VIEW_REPORTS
  STAFF_EXPORT_DATA
  STAFF_MARK_REVIEWED
  STAFF_REVIEW_UNMARKED
  STAFF_REVIEW_MARKED
  STAFF_BATCH_REVIEW

  // Webhooks
  WEBHOOK_RECEIVED

  // Admin Portal - System Operations
  CIRCUIT_BREAKER_RESET

  // Human Review System
  HUMAN_REVIEW_COMPLETED
  HUMAN_REVIEW_ASSIGNED

  // Cross-source validation
  CROSS_SOURCE_REFERENCE

  // Webhook events
  EVIDENCE_CREATED_VIA_WEBHOOK

  // Evidence staleness and content monitoring
  EVIDENCE_CONTENT_CHANGED
  SEMANTIC_DUPLICATE_DETECTED
  RULE_AUTO_DEPRECATED
  HUMAN_REVIEW_REQUESTED
}

enum ExpenseStatus {
  DRAFT
  PENDING
  PAID
  CANCELLED
}

enum PaymentMethod {
  CASH
  CARD
  TRANSFER
  OTHER
}

enum Frequency {
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

enum ReportSchedule {
  NONE
  WEEKLY
  MONTHLY
  QUARTERLY
}

enum MatchStatus {
  UNMATCHED
  AUTO_MATCHED
  MANUAL_MATCHED
  IGNORED
}

enum MatchSource {
  AUTO
  MANUAL
  SYSTEM
}

enum MatchKind {
  INVOICE
  EXPENSE
  IGNORE
  UNMATCH
}

enum ImportFormat {
  CSV
  XML_CAMT053
  MT940
  PDF
}

enum JobStatus {
  PENDING
  PROCESSING
  VERIFIED
  NEEDS_REVIEW
  FAILED
  READY_FOR_REVIEW
  CONFIRMED
  REJECTED
}

enum ExportJobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  BLOCKED
}

enum JoppdSubmissionStatus {
  PREPARED
  SUBMITTED
  ACCEPTED
  REJECTED
}

enum PayoutStatus {
  DRAFT
  LOCKED
  REPORTED
}

enum TierType {
  XML
  TEXT_LLM
  VISION_LLM
}

enum DocumentType {
  BANK_STATEMENT
  INVOICE
  EXPENSE
  PRIMKA
  IZDATNICA
}

enum StockMovementType {
  PRIMKA
  IZDATNICA
  ADJUSTMENT
}

enum StockValuationMethod {
  FIFO
  LIFO
  WEIGHTED_AVERAGE
}

enum PageStatus {
  PENDING
  VERIFIED
  NEEDS_VISION
  FAILED
}

enum TxDirection {
  INCOMING
  OUTGOING
}

enum SupportTicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SupportTicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum SyncProvider {
  GOCARDLESS
  PLAID
  SALTEDGE
}

enum ConnectionStatus {
  MANUAL
  CONNECTED
  EXPIRED
}

enum TransactionSource {
  MANUAL
  AIS_SYNC
}

enum DuplicateStatus {
  PENDING
  RESOLVED
}

enum DuplicateResolution {
  KEEP_BOTH
  MERGE
  DELETE_NEW
}

enum EmailProvider {
  GMAIL
  MICROSOFT
}

enum EmailConnectionStatus {
  CONNECTED
  EXPIRED
  REVOKED
  ERROR
}

enum AttachmentStatus {
  PENDING
  IMPORTED
  SKIPPED
  FAILED
}

enum AttachmentSource {
  UPLOAD
  EMAIL
  IMPORT
  SYSTEM
}

enum FixedAssetCandidateStatus {
  PENDING
  REVIEWED
  ACCEPTED
  REJECTED
}

enum FiscalEnv {
  TEST
  PROD
}

enum CertStatus {
  PENDING
  ACTIVE
  EXPIRED
  REVOKED
}

enum FiscalStatus {
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
  DEAD
}

enum FiscalMessageType {
  RACUN
  STORNO
  PROVJERA
}

enum FiscalResponseStatus {
  SUCCESS
  FAILED
}

enum CertificateNotificationStatus {
  PENDING // Initial state, waiting to send
  SENT // Successfully sent
  FAILED // All retries exhausted
  RETRYING // Failed but will retry
}

// =============================================================================
// INTEGRATION ACCOUNT - Multi-tenant integration credentials
// =============================================================================

enum IntegrationKind {
  EINVOICE_EPOSLOVANJE
  EINVOICE_FINA
  EINVOICE_IE_RACUNI
  FISCALIZATION_CIS
}

enum IntegrationEnv {
  TEST
  PROD
}

enum IntegrationStatus {
  ACTIVE
  DISABLED
  EXPIRED
  REVOKED
}

enum ArticleType {
  NEWS
  GUIDE
  HOWTO
  GLOSSARY
  COMPARISON
}

enum ArticleStatus {
  SYNTHESIZING
  PLANNING
  DRAFTING
  VERIFYING
  NEEDS_REVIEW
  APPROVED
  PUBLISHED
  REJECTED
}

// =============================================================================
// REGULATORY TRUTH LAYER
// =============================================================================

enum DiscoveryEndpointType {
  SITEMAP_INDEX
  SITEMAP_ISSUE
  NEWS_LISTING
  LEGAL_ACTS
  CONSULTATIONS
  TECHNICAL_DOCS
  FORMS
  CODE_LISTS
  ANNOUNCEMENTS
  STATISTICS
}

enum DiscoveryPriority {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum ScrapeFrequency {
  EVERY_RUN
  DAILY
  TWICE_WEEKLY
  WEEKLY
  MONTHLY
}

enum ListingStrategy {
  SITEMAP_XML
  HTML_LIST
  HTML_TABLE
  PAGINATION
  DATE_FILTERED
  CRAWL // Recursive site crawling to build custom sitemaps
  RSS_FEED // RSS/Atom feed parsing
}

enum DiscoveredItemStatus {
  PENDING
  FETCHED
  PROCESSED
  SKIPPED
  FAILED
}

enum DiscoveryMethod {
  SENTINEL // Daily scheduled discovery
  BACKFILL // Historical backfill discovery
}

enum BackfillRunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum BackfillMode {
  SITEMAP // Parse sitemap.xml and sitemap indexes
  ARCHIVE // Crawl archive listing pages
  PAGINATION // Iterate through paginated listings
}

enum NodeType {
  HUB // Container page (lists, indexes, sitemaps)
  LEAF // Content page (articles, regulations)
  ASSET // Binary file (PDF, DOCX, XLS)
}

enum NodeRole {
  ARCHIVE // Historical (/archive/, /2020/)
  INDEX // Navigation/pagination
  NEWS_FEED // High velocity (/vijesti/, /news/)
  REGULATION // Core legal text
  FORM // Downloadable forms (/obrasci/)
  GUIDANCE // Official guidance (/upute/, /misljenja/)
}

enum FreshnessRisk {
  CRITICAL // VAT rates, deadlines - hours matter
  HIGH // New laws, gazette items
  MEDIUM // Standard content
  LOW // Archives, FAQs
}

enum RiskTier {
  T0 // Critical: Tax rates, legal deadlines, penalties
  T1 // High: Thresholds, contribution bases
  T2 // Medium: Procedural requirements, form fields
  T3 // Low: UI labels, help text
}

enum AgentType {
  SENTINEL
  EXTRACTOR
  COMPOSER
  REVIEWER
  RELEASER
  ARBITER
  CONTENT_CLASSIFIER
  CLAIM_EXTRACTOR
  PROCESS_EXTRACTOR
  REFERENCE_EXTRACTOR
  ASSET_EXTRACTOR
  TRANSITIONAL_EXTRACTOR
  QUERY_CLASSIFIER
  COMPARISON_EXTRACTOR
  EXEMPTION_EXTRACTOR
}

// AgentRun outcome taxonomy (PR-A: 2026-01-12)
enum AgentRunStatus {
  RUNNING
  COMPLETED
  FAILED
}

enum AgentRunOutcome {
  SUCCESS_APPLIED        // Output validated and state advanced
  SUCCESS_NO_CHANGE      // Output valid but no new information
  VALIDATION_REJECTED    // Failed deterministic validation
  LOW_CONFIDENCE         // Below confidence threshold
  EMPTY_OUTPUT           // LLM returned empty/null
  PARSE_FAILED           // LLM output not valid JSON
  CONTENT_LOW_QUALITY    // Pre-filter rejected input
  SKIPPED_DETERMINISTIC  // Pre-LLM rules decided no LLM needed
  CIRCUIT_OPEN           // Circuit breaker prevented call
  DUPLICATE_CACHED       // Cache hit, no LLM call (PR-B)
  RETRY_EXHAUSTED        // All retries failed
  TIMEOUT                // Aborted due to timeout
}

enum NoChangeCode {
  ALREADY_EXTRACTED
  DUPLICATE_POINTERS
  NO_RELEVANT_CHANGES
  BELOW_MIN_CONFIDENCE
  VALIDATION_BLOCKED
}

enum RuleStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  PUBLISHED
  DEPRECATED
  REJECTED
  REVOKED // Rule was revoked after publication (deterministic rollback)
}

enum ConflictType {
  SOURCE_CONFLICT
  TEMPORAL_CONFLICT
  SCOPE_CONFLICT
  INTERPRETATION_CONFLICT
}

enum ConflictStatus {
  OPEN
  RESOLVED
  ESCALATED
}

// AlertSeverity and AlertType moved to regulatory.prisma

enum GraphEdgeType {
  AMENDS
  INTERPRETS
  REQUIRES
  EXEMPTS
  DEPENDS_ON
  SUPERSEDES
  OVERRIDES // Lex specialis - specific overrides general
}

enum AuthorityLevel {
  LAW // Legally binding (Narodne novine)
  GUIDANCE // Interpretation (Porezna uprava)
  PROCEDURE // Technical execution (FINA, HZMO, HZZO)
  PRACTICE // What passes inspections
}

enum AutomationPolicy {
  ALLOW // Safe for full automation
  CONFIRM // Requires user confirmation
  BLOCK // Manual only, no automation
}

enum RuleStability {
  STABLE // Rarely changes
  VOLATILE // Changes frequently
}

enum ObligationType {
  OBLIGATION // Must comply (e.g., "must pay 25%")
  NO_OBLIGATION // Explicitly exempt/not applicable
  CONDITIONAL // Depends on other factors (use appliesWhen)
  INFORMATIONAL // Reference value, not a requirement
}

// ============================================================================
// KNOWLEDGE SHAPES ENUMS
// ============================================================================

enum SubjectType {
  TAXPAYER
  EMPLOYER
  COMPANY
  INDIVIDUAL
  ALL
}

enum AssertionType {
  OBLIGATION
  PROHIBITION
  PERMISSION
  DEFINITION
}

enum ProcessType {
  REGISTRATION
  FILING
  APPEAL
  CLOSURE
  AMENDMENT
  INQUIRY
}

enum ReferenceCategory {
  IBAN
  CN_CODE
  TAX_OFFICE
  INTEREST_RATE
  EXCHANGE_RATE
  FORM_CODE
  DEADLINE_CALENDAR
}

enum AssetFormat {
  PDF
  XML
  XLS
  XLSX
  DOC
  DOCX
  HTML
}

enum AssetType {
  FORM
  TEMPLATE
  GUIDE
  INSTRUCTION
  REGULATION_TEXT
}

enum TransitionPattern {
  INVOICE_DATE
  DELIVERY_DATE
  PAYMENT_DATE
  EARLIER_EVENT
  LATER_EVENT
  TAXPAYER_CHOICE
}

// RegulatorySource moved to regulatory.prisma

model DiscoveryEndpoint {
  id                String                @id @default(cuid())
  domain            String // e.g., "hzzo.hr"
  path              String // e.g., "/novosti"
  name              String // Human-readable name
  endpointType      DiscoveryEndpointType
  priority          DiscoveryPriority
  scrapeFrequency   ScrapeFrequency
  listingStrategy   ListingStrategy
  urlPattern        String? // Regex for extracting item URLs
  paginationPattern String? // e.g., "?page={N}"
  lastScrapedAt     DateTime?
  lastContentHash   String? // SHA-256 of page content
  itemCount         Int                   @default(0)
  errorCount        Int                   @default(0)
  consecutiveErrors Int                   @default(0)
  lastError         String?
  isActive          Boolean               @default(true)
  metadata          Json? // Additional endpoint-specific config
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt

  discoveries DiscoveredItem[]

  @@unique([domain, path])
  @@index([priority])
  @@index([lastScrapedAt])
}

// --- Backfill Run Tracking ---
// Tracks historical backfill discovery runs with full audit trail
model BackfillRun {
  id        String            @id @default(cuid())
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  status    BackfillRunStatus @default(PENDING)

  // Configuration
  sources     Json // Array of source slugs: ["narodne-novine", "porezna-uprava"]
  mode        BackfillMode
  dateFrom    DateTime? // Optional date range filter
  dateTo      DateTime?
  maxUrls     Int              @default(1000) // Global cap per run
  concurrency Int              @default(2)
  delayMs     Int              @default(5000) // Per-domain delay
  dryRun      Boolean          @default(false)

  // Execution
  startedAt  DateTime?
  finishedAt DateTime?

  // Counters
  discoveredCount Int @default(0) // URLs discovered
  queuedCount     Int @default(0) // Jobs enqueued
  skippedCount    Int @default(0) // Already existed
  errorCount      Int @default(0) // Errors encountered

  // Metadata
  errorLog Json?   // JSON array of error details
  runBy    String? // Operator identifier (user ID or CLI)
  notes    String? // Operator notes

  // Progress tracking (for resume)
  lastProcessedSource String?
  lastProcessedPage   Int?
  lastProcessedUrl    String?
  checkpoint          Json?   // SitemapDiscoveryCheckpoint for streaming resume

  // Relations
  discoveredItems DiscoveredItem[]

  @@index([status])
  @@index([createdAt])
}

model DiscoveredItem {
  id           String               @id @default(cuid())
  endpointId   String
  url          String
  title        String?
  publishedAt  DateTime?
  contentHash  String?
  status       DiscoveredItemStatus @default(PENDING)
  processedAt  DateTime?
  evidenceId   String? // Link to Evidence if fetched
  errorMessage String?
  retryCount   Int                  @default(0)
  createdAt    DateTime             @default(now())

  // --- Discovery Method ---
  discoveryMethod DiscoveryMethod @default(SENTINEL)
  backfillRunId   String? // Link to BackfillRun if discovered via backfill

  // --- Topology ---
  nodeType  NodeType  @default(LEAF)
  nodeRole  NodeRole?
  parentUrl String?
  depth     Int       @default(0)

  // --- Velocity (EWMA: 0.0=static, 1.0=volatile) ---
  changeFrequency Float     @default(0.5)
  lastChangedAt   DateTime?
  scanCount       Int       @default(0)

  // --- Risk ---
  freshnessRisk FreshnessRisk @default(MEDIUM)

  // --- Scheduling ---
  nextScanDue DateTime @default(now())

  endpoint    DiscoveryEndpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)
  backfillRun BackfillRun?      @relation(fields: [backfillRunId], references: [id])

  @@unique([endpointId, url])
  @@index([status])
  @@index([publishedAt])
  @@index([evidenceId])
  @@index([nextScanDue, freshnessRisk]) // The "Manifest" query
  @@index([endpointId, nodeType]) // Grouping queries
  @@index([discoveryMethod])
  @@index([backfillRunId])
}

// Evidence and EvidenceArtifact moved to regulatory.prisma

model SourcePointer {
  id             String  @id @default(cuid())
  evidenceId     String
  domain         String // pausalni, pdv, doprinosi, fiskalizacija, etc.
  valueType      String // currency, percentage, date, threshold, text
  extractedValue String // Stored as string, parsed by application
  displayValue   String // Human-readable format
  exactQuote     String  @db.Text // Exact text from source
  contextBefore  String? @db.Text // Previous sentence/paragraph
  contextAfter   String? @db.Text // Following sentence/paragraph
  selector       String? // CSS selector or XPath

  // Article-level anchoring
  articleNumber   String? // e.g., "38", "12a"
  paragraphNumber String? // e.g., "1", "2"
  lawReference    String? // e.g., "Zakon o PDV-u (NN 73/13)"

  confidence      Float     @default(0.8)
  extractionNotes String?
  createdAt       DateTime  @default(now())
  deletedAt       DateTime?

  // Vector embedding for semantic search (nomic-embed-text, 768 dims)
  // Generated from exactQuote + contextBefore + contextAfter
  // Enables semantic similarity search beyond keyword matching
  embedding Unsupported("vector(768)")?

  // Provenance anchoring: UTF-16 code unit indices into Evidence.rawContent
  // These are JavaScript String.indexOf() return values, NOT byte offsets.
  // Use to slice exactQuote from rawContent: rawContent.slice(startOffset, endOffset)
  //
  // INVARIANT: endOffset = startOffset + exactQuote.length (for EXACT matches)
  // INVARIANT: rawContent.slice(startOffset, endOffset) === exactQuote (for EXACT matches)
  startOffset Int?
  endOffset   Int?
  matchType   SourcePointerMatchType? @default(PENDING_VERIFICATION)

  // evidence: FK removed - Evidence now in regulatory.prisma (soft ref via evidenceId)
  rules RegulatoryRule[] @relation("RuleSourcePointers")

  @@index([evidenceId])
  @@index([domain])
  @@index([confidence])
  @@index([articleNumber])
  @@index([matchType])
}

model Concept {
  id          String   @id @default(cuid())
  slug        String   @unique // e.g., "pausalni-obrt"
  nameHr      String
  nameEn      String?
  aliases     String[] // Alternative names
  tags        String[] // Categorization tags
  description String?  @db.Text
  parentId    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  parent    Concept?          @relation("ConceptHierarchy", fields: [parentId], references: [id])
  children  Concept[]         @relation("ConceptHierarchy")
  rules     RegulatoryRule[]
  embedding ConceptEmbedding?

  @@index([parentId])
}

model ConceptEmbedding {
  id            String                      @id @default(cuid())
  conceptId     String                      @unique
  embedding     Unsupported("vector(768)")? // pgvector embedding (768 dims for nomic-embed-text)
  embeddingText String                      @db.Text // Text that was embedded (nameHr + aliases)
  createdAt     DateTime                    @default(now())
  updatedAt     DateTime                    @updatedAt

  concept Concept @relation(fields: [conceptId], references: [id], onDelete: Cascade)

  @@index([conceptId])
}

model RegulatoryRule {
  id                String           @id @default(cuid())
  conceptSlug       String // e.g., "pausalni-revenue-threshold"
  conceptId         String?
  titleHr           String
  titleEn           String?
  riskTier          RiskTier
  authorityLevel    AuthorityLevel   @default(GUIDANCE) // LAW, GUIDANCE, PROCEDURE, PRACTICE
  automationPolicy  AutomationPolicy @default(CONFIRM) // ALLOW, CONFIRM, BLOCK
  ruleStability     RuleStability    @default(STABLE) // STABLE, VOLATILE
  appliesWhen       String           @db.Text // AppliesWhen DSL expression
  value             String // The regulatory value (stored as string)
  valueType         String // percentage, currency_hrk, currency_eur, count, date, text
  obligationType    ObligationType   @default(OBLIGATION) // OBLIGATION, NO_OBLIGATION, CONDITIONAL, INFORMATIONAL
  outcome           Json? // Structured outcome (VALUE, OBLIGATION, PROCEDURE)
  explanationHr     String?          @db.Text
  explanationEn     String?          @db.Text
  effectiveFrom     DateTime
  effectiveUntil    DateTime?
  supersedesId      String? // Previous rule this supersedes
  status            RuleStatus       @default(DRAFT)
  confidence        Float            @default(0.8) // DEPRECATED: Use derivedConfidence instead (kept for backward compatibility)
  llmConfidence     Float            @default(0.8) // LLM's self-assessed confidence in composition
  derivedConfidence Float            @default(0.8) // Confidence derived from source pointer quality (Issue #770)

  // Confidence Envelope (Mission #3: confidence, auditability, rollback)
  confidenceReasons          Json     @default("[]") // Array of {reason: ConfidenceReason, weight: number, detail?: string}
  originatingCandidateFactIds String[] // CandidateFact IDs that contributed to this rule
  originatingAgentRunIds     String[] // AgentRun IDs involved in creating this rule

  // Human Review Readiness (Mission #3)
  reviewRequired        Boolean @default(false) // True when confidence < threshold or source health poor
  reviewRequiredReasons Json?                   // Array of {reason: ReviewRequiredReason, detail?: string}

  // Rollback Capability (Mission #3)
  revokedAt     DateTime? // When the rule was revoked
  revokedReason String?   // Human-readable reason for revocation

  composerNotes     String?
  reviewerNotes     String?
  approvedBy        String? // User ID who approved (for T0/T1)
  approvedAt        DateTime?
  meaningSignature  String? // SHA256 hash of meaning-defining fields (conceptSlug+value+valueType+effectiveFrom+effectiveUntil)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  concept        Concept?             @relation(fields: [conceptId], references: [id])
  supersedes     RegulatoryRule?      @relation("RuleSupersession", fields: [supersedesId], references: [id])
  supersededBy   RegulatoryRule[]     @relation("RuleSupersession")
  sourcePointers SourcePointer[]      @relation("RuleSourcePointers")
  releases       RuleRelease[]        @relation("ReleaseRules")
  conflictsA     RegulatoryConflict[] @relation("ConflictItemA")
  conflictsB     RegulatoryConflict[] @relation("ConflictItemB")
  agentRuns      AgentRun[]
  outgoingEdges  GraphEdge[]          @relation("EdgeFrom")
  incomingEdges  GraphEdge[]          @relation("EdgeTo")
  atomicClaims   AtomicClaim[]
  eInvoiceLines  EInvoiceLine[]
  auditSnapshots AuditSnapshot[] // Immutable audit records created on Apply success

  // Allow draft/pending variants to coexist; only PUBLISHED is unique per concept/date
  // This enables conflict candidates to be stored before arbiter resolution
  @@unique([conceptSlug, effectiveFrom, status])
  @@index([status])
  @@index([riskTier])
  @@index([conceptSlug])
  @@index([effectiveFrom])
  @@index([meaningSignature])
  @@index([conceptId])
  @@index([reviewRequired]) // Mission #3: quick lookup for rules needing review
  @@index([revokedAt])      // Mission #3: quick lookup for revoked rules
}

// ============================================================================
// AUDIT SNAPSHOTS (Mission #3: confidence, auditability, rollback)
// ============================================================================
// Immutable audit records created on Apply success. These capture the full
// context at the moment a rule was created/updated, enabling deterministic
// replay and external audit.

model AuditSnapshot {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Rule linkage
  ruleId String
  rule   RegulatoryRule @relation(fields: [ruleId], references: [id])

  // Content hashes for deterministic replay
  ruleHash   String // SHA256 of rule content (conceptSlug+value+valueType+effectiveFrom+effectiveUntil+derivedConfidence)
  inputsHash String // SHA256 of inputs (candidateFactIds, agentRunIds, sourcePointerIds)

  // State snapshots at time of creation
  sourceHealthState    Json // Map of sourceSlug -> {health, stateChangedAt, decisionReason}
  routingBudgetSummary Json // Current routing/budget state from budget governor

  // Confidence snapshot
  confidenceScore   Float // derivedConfidence at time of snapshot
  confidenceReasons Json  // Array of {reason, weight, detail} at time of snapshot

  // Originating data
  candidateFactIds String[] // CandidateFact IDs used
  agentRunIds      String[] // AgentRun IDs involved
  sourcePointerIds String[] // SourcePointer IDs referenced

  // Pipeline correlation
  agentRunId String? // The AgentRun that triggered this snapshot (Apply worker)
  jobId      String? // BullMQ job ID for correlation

  @@index([ruleId])
  @@index([createdAt])
  @@index([agentRunId])
}

// ============================================================================
// FISCAL RULE TABLES - REMOVED (PR#1306)
// ============================================================================
//
// RuleTable, RuleVersion, RuleSnapshot, RuleCalculation models have been
// removed from core schema. All rule data now lives in regulatory schema.
//
// Access via: src/lib/fiscal-rules/ruleversion-store.ts
// Writes via: src/lib/fiscal-rules/service.ts (uses dbReg)
//
// TravelOrder.perDiemRuleVersionId and mileageRuleVersionId are now soft refs
// pointing to regulatory.RuleVersion IDs.
// ============================================================================

// ============================================================================
// SHAPE 1: ATOMIC CLAIMS (Logic Frames)
// ============================================================================

model AtomicClaim {
  id String @id @default(cuid())

  // WHO - Subject
  subjectType       SubjectType
  subjectQualifiers String[] // ["pausalni-obrt", "exceeds-threshold"]

  // WHEN - Condition
  triggerExpr  String? // "sales > 10000 EUR"
  temporalExpr String? // "from 2025-01-01"
  jurisdiction String  @default("HR")

  // WHAT - Assertion
  assertionType AssertionType
  logicExpr     String // "tax_place = destination"
  value         String?
  valueType     String?

  // Extensibility
  parameters Json? // Coefficients, formula constants

  // Provenance
  exactQuote    String  @db.Text
  articleNumber String?
  lawReference  String?
  confidence    Float   @default(0.8)

  // Relations
  evidenceId String // Soft ref to Evidence in regulatory.prisma
  ruleId     String?
  rule       RegulatoryRule?  @relation(fields: [ruleId], references: [id])
  exceptions ClaimException[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([subjectType])
  @@index([assertionType])
  @@index([jurisdiction])
  @@index([evidenceId])
  @@index([ruleId])
}

model ClaimException {
  id            String @id @default(cuid())
  claimId       String
  condition     String // "IF alcohol_content > 0"
  overridesTo   String // concept slug of overriding rule
  sourceArticle String // "Art 38(4)"

  claim AtomicClaim @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@index([claimId])
}

// ============================================================================
// PHASE-1: CANDIDATE FACT (Exploratory Signal Capture)
// ============================================================================
// CandidateFact captures extracted signals before promotion to canonical RuleFact.
// See: docs/audits/PHASE_1_PROOF_RUN.md

enum CandidateStatus {
  CAPTURED // Initial capture from extractor
  UNDER_REVIEW // Human reviewer is examining
  NEEDS_EVIDENCE // More grounding required
  PROMOTABLE // Ready for promotion to RuleFact
  REJECTED // Not valid/useful
  PROMOTED // Successfully promoted to RuleFact
  ARCHIVED // Historical, no longer relevant
}

model CandidateFact {
  id                   String          @id @default(cuid())
  suggestedConceptSlug String?
  suggestedDomain      String?
  subjectDescription   String?
  subjectConfidence    Float           @default(0)
  objectDescription    String?
  objectConfidence     Float           @default(0)
  conditions           String?
  conditionsConfidence Float           @default(0)
  extractedValue       String?
  suggestedValueType   String?
  valueConfidence      Float           @default(0)
  effectiveFrom        DateTime?
  effectiveUntil       DateTime?
  temporalConfidence   Float           @default(0)
  temporalNotes        String?
  suggestedAuthority   String?
  legalReferenceRaw    String?
  groundingQuotes      Json            @default("[]") @db.JsonB
  status               CandidateStatus @default(CAPTURED)
  overallConfidence    Float           @default(0)
  extractorNotes       String?
  reviewNotes          String?
  createdAt            DateTime        @default(now())
  reviewedAt           DateTime?
  reviewedBy           String?
  suggestedPillar      String?
  promotionCandidate   Boolean         @default(false)
  promotedToRuleFactId String? // Soft ref to regulatory.RuleFact

  @@index([status])
  @@index([suggestedConceptSlug])
  @@index([suggestedDomain])
  @@index([overallConfidence])
  @@index([promotionCandidate])
  @@index([createdAt])
}

// ============================================================================
// SHAPE 2: TAXONOMY (Concept Graph)
// ============================================================================

model ConceptNode {
  id     String  @id @default(cuid())
  slug   String  @unique
  nameHr String
  nameEn String?

  // Taxonomy relations
  parentId String?
  parent   ConceptNode?  @relation("ConceptNodeHierarchy", fields: [parentId], references: [id])
  children ConceptNode[] @relation("ConceptNodeHierarchy")

  // Synonyms & hyponyms
  synonyms String[] // ["sok", "juice", "voni sok"]
  hyponyms String[] // More specific terms

  // Legal categorization
  legalCategory String? // "bezalkoholno pie" (the legal term)
  vatCategory   String? // Links to VAT rate concept

  // Search optimization
  searchTerms String[] // All terms that should match this concept

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([legalCategory])
  @@index([vatCategory])
  @@index([parentId])
}

// ============================================================================
// SHAPE 4: WORKFLOW (Process Graph)
// ============================================================================

model RegulatoryProcess {
  id           String  @id @default(cuid())
  slug         String  @unique
  titleHr      String
  titleEn      String?
  jurisdiction String  @default("HR")

  // Process metadata
  processType   ProcessType
  estimatedTime String? // "3-5 radnih dana"

  // Prerequisites as JSON
  prerequisites Json? // { "requires": ["digital-certificate"] }

  // Relations
  steps      ProcessStep[]
  assets     RegulatoryAsset[]
  evidenceId String? // Soft ref to Evidence in regulatory.prisma

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([processType])
  @@index([jurisdiction])
  @@index([evidenceId])
}

model ProcessStep {
  id        String @id @default(cuid())
  processId String
  orderNum  Int

  // Step content
  actionHr String  @db.Text
  actionEn String? @db.Text

  // Dependencies (by ID for loose coupling)
  requiresStepIds String[]
  requiresAssets  String[]

  // Branching
  onSuccessStepId String?
  onFailureStepId String?
  failureAction   String?

  process RegulatoryProcess @relation(fields: [processId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([processId, orderNum])
  @@index([processId])
}

// ============================================================================
// SHAPE 5: REFERENCE (Lookup Tables)
// ============================================================================

model ReferenceTable {
  id           String            @id @default(cuid())
  category     ReferenceCategory
  name         String
  jurisdiction String            @default("HR")

  // Table metadata
  keyColumn   String // "city", "code"
  valueColumn String // "iban", "description"

  // Data
  entries ReferenceEntry[]

  // Provenance
  sourceUrl   String?
  lastUpdated DateTime @default(now())
  evidenceId  String? // Soft ref to Evidence in regulatory.prisma

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([category, name, jurisdiction])
  @@index([category])
  @@index([jurisdiction])
}

model ReferenceEntry {
  id      String @id @default(cuid())
  tableId String

  key      String // "Split", "6201.11"
  value    String // "HR1234...", "Raunalne usluge"
  metadata Json? // { "model": "21" }

  table ReferenceTable @relation(fields: [tableId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([tableId, key])
  @@index([tableId])
}

// ============================================================================
// SHAPE 6: DOCUMENT (Asset Repository)
// ============================================================================

model RegulatoryAsset {
  id String @id @default(cuid())

  // Identity
  formCode     String? // "PDV-P", "JOPPD"
  officialName String
  description  String? @db.Text

  // Access
  downloadUrl String
  format      AssetFormat
  fileSize    Int?

  // Context
  assetType  AssetType
  processId  String?
  process    RegulatoryProcess? @relation(fields: [processId], references: [id])
  stepNumber Int?

  // Validity
  validFrom  DateTime?
  validUntil DateTime?
  version    String?

  // Provenance
  sourceUrl  String
  evidenceId String? // Soft ref to Evidence in regulatory.prisma

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([formCode])
  @@index([assetType])
  @@index([processId])
  @@index([evidenceId])
}

// ============================================================================
// SHAPE 7: TEMPORAL (Transitional Provisions)
// ============================================================================

model TransitionalProvision {
  id String @id @default(cuid())

  // What's transitioning
  fromRule String // concept slug of old rule
  toRule   String // concept slug of new rule

  // Transition logic
  cutoffDate  DateTime
  logicExpr   String // "IF invoice_date < cutoff AND delivery_date >= cutoff"
  appliesRule String // Which rule applies

  // Explanation
  explanationHr String  @db.Text
  explanationEn String? @db.Text

  // Pattern
  pattern TransitionPattern

  // Provenance
  sourceArticle String
  evidenceId    String // Soft ref to Evidence in regulatory.prisma

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cutoffDate])
  @@index([fromRule])
  @@index([toRule])
  @@index([evidenceId])
}

// Truth health snapshot for monitoring system integrity
model TruthHealthSnapshot {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())

  // Rule counts by status
  totalRules         Int
  publishedRules     Int
  approvedRules      Int
  pendingReviewRules Int
  draftRules         Int
  rejectedRules      Int

  // Pointer coverage metrics
  totalPointers        Int
  unlinkedPointers     Int // Pointers not linked to any rule
  unlinkedPointersRate Float // % unlinked (lower = better)

  // Evidence quality
  rulesWithMultiplePointers Int // Rules with >1 pointer
  multiplePointerRate       Float // % of non-rejected rules with >1 pointer
  publishedWithTwoPlus      Int // PUBLISHED rules with >=2 pointers
  publishedPointerCoverage  Float // % of PUBLISHED with >=2 pointers

  // Consolidation health
  duplicateGroupsDetected Int // Should always be 0
  testDataLeakage         Int // Test domain data in non-quarantine status
  aliasResolutionsToday   Int // Composer runs that resolved to canonical

  // Concept health
  totalConcepts     Int
  conceptsWithRules Int
  orphanedConcepts  Int // Concepts with no rules

  // Evidence strength metrics
  multiSourceRules       Int @default(0) // Rules with 2+ distinct sources
  singleSourceRules      Int @default(0) // Rules with only 1 source
  singleSourceCanPublish Int @default(0) // Single-source with LAW tier
  singleSourceBlocked    Int @default(0) // Single-source blocked from publish

  // Alerts triggered
  alertsTriggered String[] // List of alert types triggered

  @@index([timestamp])
}

model GraphEdge {
  id         String        @id @default(cuid())
  fromRuleId String
  toRuleId   String
  relation   GraphEdgeType
  validFrom  DateTime
  validTo    DateTime?
  notes      String?
  createdAt  DateTime      @default(now())

  fromRule RegulatoryRule @relation("EdgeFrom", fields: [fromRuleId], references: [id], onDelete: Cascade)
  toRule   RegulatoryRule @relation("EdgeTo", fields: [toRuleId], references: [id], onDelete: Cascade)

  @@unique([fromRuleId, toRuleId, relation])
  @@index([fromRuleId])
  @@index([toRuleId])
}

model RuleRelease {
  id            String   @id @default(cuid())
  version       String // semver: "1.0.0"
  releaseType   String // major, minor, patch
  releasedAt    DateTime @default(now())
  effectiveFrom DateTime
  contentHash   String // SHA-256 of rule content
  changelogHr   String?  @db.Text
  changelogEn   String?  @db.Text
  approvedBy    String[] // List of approver user IDs
  auditTrail    Json? // { sourceEvidenceCount, sourcePointerCount, reviewCount, humanApprovals }

  rules RegulatoryRule[] @relation("ReleaseRules")

  @@unique([version])
  @@index([releasedAt])
  @@index([effectiveFrom])
}

model AgentRun {
  id          String         @id @default(cuid())
  agentType   AgentType
  status      AgentRunStatus @default(RUNNING)

  // Input/Output
  input       Json
  output      Json?
  rawOutput   Json?
  error       String?

  // Metrics
  tokensUsed  Int?
  inputChars  Int?
  inputBytes  Int?
  durationMs  Int?
  confidence  Float?

  // Prompt provenance
  promptTemplateId      String?
  promptTemplateVersion String?
  promptHash            String?

  // Outcome taxonomy
  outcome        AgentRunOutcome?
  noChangeCode   NoChangeCode?
  noChangeDetail String?
  itemsProduced  Int              @default(0)

  // Correlation
  runId       String?
  jobId       String?
  parentJobId String?
  sourceSlug  String?
  queueName   String?

  // Retry tracking
  attempt     Int @default(1)

  // Cache metadata (for PR-B)
  inputContentHash String?
  cacheHit         Boolean @default(false)

  // Linkage
  evidenceId String? // Soft ref to Evidence in regulatory.prisma
  ruleId     String?
  rule       RegulatoryRule? @relation(fields: [ruleId], references: [id])

  startedAt   DateTime @default(now())
  completedAt DateTime?

  @@index([agentType])
  @@index([status])
  @@index([outcome])
  @@index([startedAt])
  @@index([agentType, outcome, startedAt])
  @@index([queueName, outcome, startedAt])
  @@index([inputContentHash])
  @@index([runId])
  @@index([sourceSlug, startedAt])
}

/// Cache for agent LLM results to avoid redundant API calls
/// Key: (agentType, provider, model, promptHash, inputContentHash)
/// Only stores SUCCESS_APPLIED and SUCCESS_NO_CHANGE outcomes
model AgentResultCache {
  id               String    @id @default(cuid())
  agentType        AgentType
  provider         String    // e.g. "ollama_cloud", "openai"
  model            String    // e.g. "gemma-3-27b"
  promptHash       String
  inputContentHash String

  // Cached result (validated output artifact - no outcome stored)
  output           Json      // The validated output JSON
  confidence       Float?
  tokensUsed       Int?

  // Metadata
  originalRunId    String?   // Reference to the AgentRun that created this cache entry
  hitCount         Int       @default(0) // Number of times this cache entry was used
  createdAt        DateTime  @default(now())
  lastHitAt        DateTime?

  @@unique([agentType, provider, model, promptHash, inputContentHash])
  @@index([agentType, inputContentHash])
  @@index([createdAt])
}

/// Pipeline progress tracking for observability
/// Records every stage execution to answer "Did we spend tokens and get persisted value?"
model PipelineProgress {
  id                    String    @id @default(cuid())
  stageName             String    // scout, router, ocr, extract, compose, apply, review, arbiter, release
  evidenceId            String?   // Soft ref to Evidence
  sourceSlug            String
  runId                 String
  timestamp             DateTime  @default(now())

  // Metrics
  producedCount         Int       @default(0) // Items created by this stage
  downstreamQueuedCount Int       @default(0) // Jobs queued to next stage
  tokensUsed            Int?      // LLM tokens consumed
  durationMs            Int?      // Processing time

  // Skip/Error tracking
  skipReason            String?   // Why skipped (if applicable)
  errorClass            String?   // TRANSIENT, VALIDATION, AUTH, QUOTA, CONTENT, INTERNAL
  errorMessage          String?   @db.Text

  // Stage-specific metadata
  metadata              Json?

  @@index([stageName, timestamp])
  @@index([sourceSlug, timestamp])
  @@index([runId])
  @@index([timestamp])
  @@index([stageName, sourceSlug, timestamp])
}

// Source Health: Rolling metrics for adaptive routing and budget allocation
// Updated after each batch to enable self-correcting behavior
model SourceHealth {
  id                  String    @id @default(cuid())
  sourceSlug          String    @unique // Identifier for the regulatory source

  // Rolling success metrics (window-based, e.g., last 7 days)
  windowStartAt       DateTime  @default(now()) // Start of current rolling window
  windowSizeHours     Int       @default(168)   // 7 days default

  // Outcome counts in current window
  totalAttempts       Int       @default(0)     // Total LLM calls attempted
  successCount        Int       @default(0)     // itemsProduced > 0
  emptyCount          Int       @default(0)     // itemsProduced = 0 but no error
  errorCount          Int       @default(0)     // Errors/failures

  // Token efficiency metrics
  totalTokensUsed     Int       @default(0)     // Tokens spent in window
  totalItemsProduced  Int       @default(0)     // Rules/facts created
  avgTokensPerItem    Float     @default(0)     // Rolling avg: tokens / items

  // Derived health score (0-1, higher = better)
  healthScore         Float     @default(0.5)   // Computed from metrics

  // Pause/cooldown state
  isPaused            Boolean   @default(false) // If true, no LLM budget allocated
  pausedAt            DateTime? // When paused
  pauseReason         String?   // Why paused (LOW_HEALTH, MANUAL, etc.)
  pauseExpiresAt      DateTime? // Auto-unpause time

  // Adaptive thresholds (set based on health)
  minScoutScore       Float     @default(0.4)   // Min worthItScore to proceed
  allowCloud          Boolean   @default(true)  // Whether cloud LLM is permitted
  budgetMultiplier    Float     @default(1.0)   // 0-2, scales per-source cap

  // Stability: Health state tracking with dwell time (anti-flapping)
  healthState             String    @default("FAIR")    // EXCELLENT, GOOD, FAIR, POOR, CRITICAL
  healthStateEnteredAt    DateTime  @default(now())     // When current state was entered
  previousHealthState     String?                       // For audit trail

  // Explainability: Last decision tracking
  lastDecisionReason      String?   // Enum: HEALTH_UPGRADE, HEALTH_DOWNGRADE, AUTO_PAUSE, AUTO_UNPAUSE, MANUAL_PAUSE, STARVATION_ALLOWANCE
  lastDecisionAt          DateTime? // When the decision was made
  lastDecisionDetails     Json?     // { triggeredBy, metricValue, threshold, previousValue }

  // Starvation guard: Minimum evaluation allowance for rare sources
  lastStarvationAllowanceAt DateTime? // When last starvation allowance was granted
  starvationAllowanceCount  Int       @default(0) // How many allowances granted in window

  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  lastBatchAt         DateTime? // Last time metrics were updated

  @@index([healthScore])
  @@index([isPaused])
  @@index([updatedAt])
  @@index([healthState])
  @@index([lastDecisionAt])
}

model RegulatoryConflict {
  id                  String         @id @default(cuid())
  conflictType        ConflictType
  status              ConflictStatus @default(OPEN)
  itemAId             String?
  itemBId             String?
  description         String         @db.Text
  metadata            Json? // Source-level conflicts store sourcePointerIds here
  resolution          Json? // { winningItemId, strategy, rationaleHr, rationaleEn }
  confidence          Float?
  requiresHumanReview Boolean        @default(false)
  humanReviewReason   String?
  resolvedBy          String? // User ID
  resolvedAt          DateTime?
  createdAt           DateTime       @default(now())

  itemA RegulatoryRule? @relation("ConflictItemA", fields: [itemAId], references: [id])
  itemB RegulatoryRule? @relation("ConflictItemB", fields: [itemBId], references: [id])

  @@index([status])
  @@index([conflictType])
  @@index([createdAt])
}

// MonitoringAlert moved to regulatory.prisma

// =============================================================================
// AUDIT LOG - Legal Defense Layer
// =============================================================================

model RegulatoryAuditLog {
  id          String   @id @default(cuid())
  action      String // RULE_CREATED, RULE_APPROVED, RULE_REJECTED, CONFLICT_RESOLVED, RELEASE_PUBLISHED
  entityType  String // RULE, CONFLICT, RELEASE, EVIDENCE
  entityId    String
  performedBy String? // User ID or "SYSTEM"
  performedAt DateTime @default(now())
  metadata    Json? // Additional context

  @@index([entityType, entityId])
  @@index([performedAt])
  @@index([action])
}

// ConflictResolutionAudit moved to regulatory.prisma

// =============================================================================
// HUMAN REVIEW QUEUE - Centralized review management (Issue #884)
// =============================================================================

enum HumanReviewPriority {
  CRITICAL
  HIGH
  NORMAL
  LOW
}

enum HumanReviewStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  EXPIRED
}

model HumanReviewQueue {
  id          String              @id @default(cuid())
  entityType  String // EVIDENCE, RULE, CONFLICT, SOURCE_POINTER
  entityId    String
  reason      String // HumanReviewReason enum value
  priority    HumanReviewPriority @default(NORMAL)
  status      HumanReviewStatus   @default(PENDING)
  context     Json? // Additional context for the reviewer
  requestedBy String // Source of the request (e.g., "ocr-worker", "arbiter")
  requestedAt DateTime            @default(now())
  slaDeadline DateTime // When review should be completed by
  assignedTo  String? // User ID assigned to review
  completedAt DateTime?
  completedBy String? // User ID who completed the review
  resolution  Json? // Resolution details

  @@index([status])
  @@index([priority])
  @@index([entityType, entityId])
  @@index([slaDeadline])
  @@index([requestedAt])
}

// =============================================================================
// WATCHDOG SYSTEM - Autonomous Monitoring & Health Checks
// =============================================================================

enum WatchdogSeverity {
  INFO
  WARNING
  CRITICAL
}

enum WatchdogHealthStatus {
  HEALTHY
  WARNING
  CRITICAL
}

enum WatchdogCheckType {
  STALE_SOURCE
  SCRAPER_FAILURE
  QUALITY_DEGRADATION
  PIPELINE_HEALTH
  REJECTION_RATE
  DRAINER_PROGRESS // PR #90 fix: detect drainer stalls
  QUEUE_BACKLOG // PR #90 fix: detect queue buildup
  DLQ_HEALTH // PR #90 fix: dead letter queue monitoring
  LLM_PROVIDER_HEALTH // PR-1: Ollama/OpenAI/DeepSeek reachability
  // PR-2: Progress gate checks (pipeline stage stall detection)
  PROGRESS_GATE_EVIDENCE // Evidence  SourcePointer stall detection
  PROGRESS_GATE_EXTRACTION // SourcePointer  Rule stall detection
  PROGRESS_GATE_RELEASE // Approved  Published stall detection
}

enum WatchdogAlertType {
  STALE_SOURCE
  SCRAPER_FAILURE
  QUALITY_DEGRADATION
  PIPELINE_FAILURE
  PHASE_TIMEOUT
  HIGH_REJECTION_RATE
  AUDIT_FAIL
  AUDIT_PARTIAL
  SOURCE_SUSPENDED
  DRAINER_STALL // PR #90 fix: no progress for N minutes
  QUEUE_BACKLOG // PR #90 fix: queue depth exceeds threshold
  DLQ_SPIKE // PR #90 fix: dead letter queue growing
  // Endpoint health alerts (Discovery v1)
  ENDPOINT_SLA_BREACH // CRITICAL endpoint lastSuccessAt > 24h
  ENDPOINT_CONSECUTIVE_ERRORS // CRITICAL endpoint consecutiveErrors >= 3
  CIRCUIT_BREAKER_OPEN // Domain circuit breaker tripped
  ENDPOINT_RECOVERED // Previously unhealthy endpoint now healthy (Slack-only)
  // LLM Provider health alerts (PR-1)
  LLM_PROVIDER_DOWN // PR-1: Provider unreachable
  LLM_CIRCUIT_OPEN // PR-1: Circuit breaker tripped
  // PR-2: Progress gate alerts (pipeline stage stall detection)
  PROGRESS_STALL_EVIDENCE // Evidence stuck without extraction
  PROGRESS_STALL_EXTRACTION // Extraction stuck without rule
  PROGRESS_STALL_RELEASE // Approved stuck without release
}

enum AuditResult {
  PASS
  PARTIAL
  FAIL
}

enum SourcePointerMatchType {
  EXACT // Quote found exactly as stored
  NORMALIZED // Quote found after whitespace/unicode normalization
  NOT_FOUND // Quote does not exist in evidence (broken provenance)
  PENDING_VERIFICATION // Quote not yet checked against evidence
}

// ============================================================================
// SYSTEM STATUS (Human Control Layer)
// ============================================================================

enum SystemStatusHeadline {
  OK
  ATTENTION
  ACTION_REQUIRED
}

enum SystemStatusRefreshStatus {
  SUCCESS
  FAILED
}

enum SystemStatusRefreshQuality {
  FULL
  DEGRADED
}

enum SystemStatusEventType {
  NEW_CRITICAL
  CRITICAL_RESOLVED
  OWNER_CHANGED
  NEW_OBSERVED
  DECLARED_MISSING
  UNKNOWN_INTEGRATION
  REFRESH_FAILED
  REFRESH_DEGRADED
  CIRCUIT_BREAKER_RESET
}

enum SystemStatusJobStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
}

enum SystemStatusJobMode {
  SYNC
  ASYNC
}

model WatchdogHealth {
  id          String               @id @default(cuid())
  checkType   WatchdogCheckType
  entityId    String // source ID, phase name, etc.
  status      WatchdogHealthStatus
  lastChecked DateTime             @default(now())
  lastHealthy DateTime?
  metric      Decimal?             @db.Decimal(10, 4)
  threshold   Decimal?             @db.Decimal(10, 4)
  message     String?

  @@unique([checkType, entityId])
  @@index([status])
  @@index([checkType])
}

model WatchdogAlert {
  id              String            @id @default(cuid())
  severity        WatchdogSeverity
  type            WatchdogAlertType
  entityId        String?
  message         String
  details         Json?
  occurredAt      DateTime          @default(now())
  acknowledgedAt  DateTime?
  acknowledgedBy  String?
  resolvedAt      DateTime?
  notifiedAt      DateTime?
  occurrenceCount Int               @default(1)

  @@index([severity])
  @@index([type])
  @@index([occurredAt])
  @@index([resolvedAt])
}

// =============================================================================
// ADMIN ALERTS - Platform monitoring and alert management
// =============================================================================

enum AdminAlertStatus {
  ACTIVE
  ACKNOWLEDGED
  DISMISSED
  RESOLVED
}

model AdminAlert {
  id             String           @id @default(cuid())
  type           String // onboarding-stuck, approaching-limit, critical-limit, cert-expiring, cert-expired, inactive, support-ticket
  level          String // critical, warning, info
  companyId      String
  status         AdminAlertStatus @default(ACTIVE)
  title          String
  description    String           @db.Text
  autoAction     String?
  metadata       Json? // Store additional context (e.g., revenue, days remaining)
  createdAt      DateTime         @default(now())
  acknowledgedAt DateTime?
  acknowledgedBy String? // User ID who acknowledged
  dismissedAt    DateTime?
  dismissedBy    String? // User ID who dismissed
  resolvedAt     DateTime?
  resolvedBy     String? // User ID who resolved
  snoozedUntil   DateTime? // For snooze functionality

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, type])
  @@index([companyId])
  @@index([type])
  @@index([level])
  @@index([status])
  @@index([createdAt])
}

model WatchdogAudit {
  id           String      @id @default(cuid())
  runDate      DateTime    @db.Date
  auditedAt    DateTime    @default(now())
  rulesAudited Int
  rulesPassed  Int
  rulesFailed  Int
  overallScore Decimal     @db.Decimal(5, 2)
  result       AuditResult
  findings     Json
  alertsRaised String[]

  @@index([runDate])
  @@index([result])
}

// =============================================================================
// ExtractionRejected moved to regulatory.prisma

// =============================================================================
// SOFT FAIL LOG - Track AI operation failures
// =============================================================================

model SoftFailLog {
  id           String   @id @default(cuid())
  operation    String // e.g., "extractor", "reviewer", "composer"
  entityType   String? // e.g., "evidence", "rule", "source"
  entityId     String?
  errorMessage String   @db.Text
  metadata     Json? // Additional context (duration, stack trace, etc.)
  createdAt    DateTime @default(now())

  @@index([operation])
  @@index([createdAt])
  @@index([entityType, entityId])
}

// === REASONING TRACE (Visible Reasoning UX Audit Trail) ===
model ReasoningTrace {
  id                  String @id @default(cuid())
  requestId           String @unique
  events              Json // Full typed ReasoningEvent[]
  userContextSnapshot Json // Frozen at request start

  // Summary columns for fast queries
  outcome           String // ANSWER | QUALIFIED_ANSWER | REFUSAL | ERROR
  domain            String?
  riskTier          String?
  confidence        Float?
  sourceCount       Int?
  eligibleRuleCount Int?
  exclusionCount    Int?
  conflictCount     Int?
  refusalReason     String?
  durationMs        Int?

  createdAt DateTime @default(now())

  @@index([requestId])
  @@index([outcome])
  @@index([riskTier])
  @@index([createdAt])
  @@index([confidence])
}

// ============================================================================
// BETA FEEDBACK
// ============================================================================

model BetaFeedback {
  id        String   @id @default(cuid())
  userId    String
  feature   String // e.g. "reasoning", "ai-assistant"
  rating    Int? // 1-5 star rating
  feedback  String? // Free-form text feedback
  category  String? // "bug", "suggestion", "praise", "other"
  metadata  Json? // Additional context (browser, page, etc.)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([feature])
  @@index([createdAt])
}

// ============================================================================
// COVERAGE TRACKING
// ============================================================================

model CoverageReport {
  id         String   @id @default(cuid())
  evidenceId String
  createdAt  DateTime @default(now())

  // Extraction counts by shape
  claimsCount          Int @default(0)
  processesCount       Int @default(0)
  referenceTablesCount Int @default(0)
  assetsCount          Int @default(0)
  provisionsCount      Int @default(0)

  // Legacy extraction (for comparison)
  sourcePointersCount Int @default(0)

  // Classification
  primaryContentType       String? // LOGIC, PROCESS, REFERENCE, etc.
  classificationConfidence Float   @default(0)

  // Coverage assessment
  coverageScore Float    @default(0) // 0-1, overall coverage
  isComplete    Boolean  @default(false)
  missingShapes String[] // ["claims", "processes"]
  warnings      String[] // Quality warnings

  // Reviewer status
  reviewerApproved Boolean   @default(false)
  reviewerNotes    String?
  reviewedAt       DateTime?
  reviewedBy       String?

  // Relations - evidenceId is soft ref to Evidence in regulatory.prisma

  @@unique([evidenceId])
  @@index([coverageScore])
  @@index([isComplete])
  @@index([createdAt])
}

// ============================================================================
// SHAPE 8: COMPARISON MATRIX (Strategic Comparisons)
// ============================================================================

model ComparisonMatrix {
  id      String  @id @default(cuid())
  slug    String  @unique
  titleHr String
  titleEn String?

  // Contextual Anchor for retrieval
  appliesWhen String?  @db.Text // "IF user_type == 'freelancer' OR revenue < 40000"
  domainTags  String[] // ["STARTING_BUSINESS", "TAX_REGIME"]

  // Structured data (JSON for flexibility)
  options  Json // ComparisonOption[]
  criteria Json // ComparisonCriterion[]
  cells    Json // ComparisonCell[]

  // Optional conclusion
  conclusion String? @db.Text

  // Provenance
  evidenceId String? // Soft ref to Evidence in regulatory.prisma

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([domainTags])
  @@index([evidenceId])
}

// ============================================================================
// SYSTEM STATUS MODELS (Human Control Layer)
// ============================================================================

model SystemRegistryStatusSnapshot {
  id                   String                     @id @default(cuid())
  headlineStatus       SystemStatusHeadline
  refreshQuality       SystemStatusRefreshQuality
  criticalCount        Int
  highCount            Int
  mediumCount          Int
  lowCount             Int
  observedCount        Int
  declaredCount        Int
  newDriftSinceDays    Int
  lastRefreshStartedAt DateTime?
  lastRefreshEndedAt   DateTime?
  lastRefreshStatus    SystemStatusRefreshStatus?
  lastRefreshError     String?
  topItems             Json
  createdAt            DateTime                   @default(now())

  @@index([createdAt])
}

model SystemRegistryStatusPointer {
  id        String   @id @default(cuid())
  currentId String
  updatedAt DateTime @updatedAt
}

model SystemRegistryStatusEvent {
  id                String                @id @default(cuid())
  eventType         SystemStatusEventType
  severity          String
  message           String
  nextAction        String
  componentId       String?
  owner             String?
  link              String?
  requestedByUserId String?
  createdAt         DateTime              @default(now())

  @@index([createdAt])
  @@index([eventType])
}

model SystemRegistryRefreshJob {
  id                String                @id @default(cuid())
  status            SystemStatusJobStatus
  mode              SystemStatusJobMode
  dedupeKey         String
  lockKey           String
  requestedByUserId String
  startedAt         DateTime?
  finishedAt        DateTime?
  timeoutSeconds    Int
  error             String?
  snapshotId        String?
  createdAt         DateTime              @default(now())

  @@index([dedupeKey])
  @@index([status])
}

model SystemRegistryRefreshLock {
  id                String   @id @default(cuid())
  lockKey           String   @unique
  lockedUntil       DateTime
  startedAt         DateTime
  requestedByUserId String
  jobId             String
}

// ============================================================================
// FEATURE FLAG MANAGEMENT
// ============================================================================

enum FeatureFlagScope {
  GLOBAL // Applies to all users/tenants
  TENANT // Applies to specific companies
  USER // Applies to specific users
}

enum FeatureFlagStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
  DELETED
}

model FeatureFlag {
  id          String            @id @default(cuid())
  key         String            @unique // e.g., "reasoning_ux", "ai_assistant_v2"
  name        String // Human-readable name
  description String?           @db.Text
  checksum    String?
  scope       FeatureFlagScope  @default(GLOBAL)
  status      FeatureFlagStatus @default(INACTIVE)

  // Value configuration
  defaultValue Boolean @default(false)

  // Rollout configuration
  rolloutPercentage Int @default(0) // 0-100 for gradual rollout

  // Metadata
  category String? // e.g., "ai", "billing", "ux"
  tags     String[] // For filtering/searching

  // Audit trail
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  createdBy String? // User ID who created
  updatedBy String? // User ID who last updated
  deletedAt DateTime? // Soft-delete timestamp
  deletedBy String? // User ID who soft-deleted

  // Relations
  overrides      FeatureFlagOverride[]
  auditLog       FeatureFlagAuditLog[]
  segmentTargets SegmentFeatureTarget[]

  @@index([key])
  @@index([status])
  @@index([category])
  @@index([tags])
  @@index([deletedAt])
}

// =============================================================================
// CORE DOMAIN MODELS
// =============================================================================

enum AccountingPeriodStatus {
  OPEN
  LOCKED
}

enum ArtifactType {
  PDF
  XML
}

model Artifact {
  id                String       @id @default(cuid())
  companyId         String
  type              ArtifactType
  fileName          String
  contentType       String
  sizeBytes         Int
  storageKey        String
  checksum          String
  checksumAlgorithm String       @default("SHA256")
  generatorVersion  String       @default("unknown")
  inputHash         String?
  generationMeta    Json?
  createdById       String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  company           Company      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdBy         User?        @relation("ArtifactCreator", fields: [createdById], references: [id])

  @@index([companyId])
  @@index([type])
  @@index([checksum])
}

model Permission {
  id          String           @id @default(cuid())
  key         String           @unique
  description String?
  checksum    String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  roles       RolePermission[]

  @@index([key])
}

model RolePermission {
  id           String     @id @default(cuid())
  role         Role
  permissionId String
  grantedBy    String?
  createdAt    DateTime   @default(now())
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([role, permissionId])
  @@index([role])
  @@index([permissionId])
}

model FeatureFlagOverride {
  id     String      @id @default(cuid())
  flagId String
  flag   FeatureFlag @relation(fields: [flagId], references: [id], onDelete: Cascade)

  // Target (one of these should be set based on flag scope)
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId    String?

  // Override value
  enabled Boolean

  // Scheduling
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([flagId, companyId, userId])
  @@index([flagId])
  @@index([companyId])
  @@index([userId])
  @@index([expiresAt])
}

enum FeatureFlagAuditAction {
  CREATED
  UPDATED
  ENABLED
  DISABLED
  ARCHIVED
  OVERRIDE_ADDED
  OVERRIDE_REMOVED
  ROLLOUT_CHANGED
  DELETED
  RESTORED
}

model FeatureFlagAuditLog {
  id            String                 @id @default(cuid())
  flagId        String
  flag          FeatureFlag            @relation(fields: [flagId], references: [id], onDelete: Cascade)
  action        FeatureFlagAuditAction
  userId        String // Who made the change
  previousValue Json? // Snapshot of previous state
  newValue      Json? // Snapshot of new state
  reason        String? // Optional reason for change
  createdAt     DateTime               @default(now())

  @@index([flagId])
  @@index([userId])
  @@index([createdAt])
}

// =============================================================================
// User Segmentation System
// =============================================================================

enum SegmentStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

enum SegmentOperator {
  EQUALS
  NOT_EQUALS
  IN
  NOT_IN
  GREATER_THAN
  LESS_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN_OR_EQUAL
  CONTAINS
  NOT_CONTAINS
  IS_NULL
  IS_NOT_NULL
}

enum SegmentLogicOperator {
  AND
  OR
}

model UserSegment {
  id          String        @id @default(cuid())
  name        String        @unique
  description String?       @db.Text
  status      SegmentStatus @default(DRAFT)

  // Rules DSL stored as JSON
  // Example: { "operator": "AND", "conditions": [{ "field": "legalForm", "operator": "IN", "value": ["OBRT_PAUSAL", "OBRT_REAL"] }] }
  rules Json

  // Cached metrics (updated by background job)
  memberCount     Int       @default(0)
  lastEvaluatedAt DateTime?

  // Metadata
  category String? // e.g., "legal_form", "subscription", "behavior"
  tags     String[]
  isSystem Boolean  @default(false) // System segments cannot be deleted

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  featureTargeting  SegmentFeatureTarget[]
  membershipHistory SegmentMembershipHistory[]
  experiments       ExperimentSegment[]

  @@index([status])
  @@index([category])
  @@index([tags])
}

// Track segment membership changes over time for cohort analysis
model SegmentMembershipHistory {
  id        String      @id @default(cuid())
  segmentId String
  segment   UserSegment @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  companyId String

  // Membership change
  joined      Boolean // true = joined, false = left
  evaluatedAt DateTime @default(now())

  // Snapshot of company attributes at evaluation time
  attributeSnapshot Json?

  @@index([segmentId])
  @@index([companyId])
  @@index([evaluatedAt])
}

// Connect segments to feature flags for targeting
model SegmentFeatureTarget {
  id        String      @id @default(cuid())
  segmentId String
  segment   UserSegment @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  flagId    String
  flag      FeatureFlag @relation(fields: [flagId], references: [id], onDelete: Cascade)

  // Override behavior
  enabled  Boolean @default(true)
  priority Int     @default(0) // Higher priority wins in conflicts

  // Scheduling
  startsAt  DateTime?
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([segmentId, flagId])
  @@index([segmentId])
  @@index([flagId])
}

// Product experiments using segments
model Experiment {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?          @db.Text
  status      ExperimentStatus @default(DRAFT)

  // Experiment configuration
  hypothesis     String?   @db.Text
  startDate      DateTime?
  endDate        DateTime?
  trafficPercent Int       @default(100) // % of segment to include

  // Results tracking
  successMetric String? // e.g., "conversion_rate", "retention"
  controlValue  Float?
  variantValue  Float?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  // Relations
  segments    ExperimentSegment[]
  variants    ExperimentVariant[]
  assignments ExperimentAssignment[]
  events      ExperimentEvent[]

  @@index([status])
}

model ExperimentSegment {
  id           String      @id @default(cuid())
  experimentId String
  experiment   Experiment  @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  segmentId    String
  segment      UserSegment @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  // Segment can be control or treatment
  isControl Boolean @default(false)

  @@unique([experimentId, segmentId])
  @@index([experimentId])
  @@index([segmentId])
}

model ExperimentVariant {
  id           String     @id @default(cuid())
  experimentId String
  experiment   Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  name        String // e.g., "control", "variant_a", "variant_b"
  description String?
  weight      Int     @default(50) // Traffic weight percentage
  config      Json? // Variant-specific configuration

  // Relations
  assignments ExperimentAssignment[]
  events      ExperimentEvent[]

  @@unique([experimentId, name])
  @@index([experimentId])
}

enum ExperimentStatus {
  DRAFT
  RUNNING
  PAUSED
  COMPLETED
  CANCELLED
}

// User experiment assignments for sticky sessions
model ExperimentAssignment {
  id           String    @id @default(cuid())
  experimentId String
  userId       String
  variantId    String
  assignedAt   DateTime  @default(now())
  exposedAt    DateTime? // First time user was exposed to variant
  convertedAt  DateTime? // If user completed success metric

  experiment Experiment        @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  variant    ExperimentVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([experimentId, userId])
  @@index([experimentId])
  @@index([userId])
  @@index([variantId])
  @@index([exposedAt])
}

// Event tracking for experiment analysis
model ExperimentEvent {
  id           String   @id @default(cuid())
  experimentId String
  userId       String
  variantId    String
  eventType    String // e.g., "view", "click", "conversion"
  eventName    String // e.g., "invoice_created", "signup_completed"
  properties   Json? // Additional event data
  timestamp    DateTime @default(now())

  experiment Experiment        @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  variant    ExperimentVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([experimentId])
  @@index([userId])
  @@index([variantId])
  @@index([eventType])
  @@index([eventName])
  @@index([timestamp])
}

// ============================================================================
// WEBHOOK & PUSH NOTIFICATION INFRASTRUCTURE
// ============================================================================

// Webhook subscriptions for regulatory sources
model WebhookSubscription {
  id          String  @id @default(cuid())
  sourceId    String? // Soft ref to RegulatorySource in regulatory.prisma
  provider    String // e.g., "narodne-novine", "porezna-uprava", "fina", "custom"
  webhookType String // RSS_FEED, EMAIL_ALERT, HTTP_WEBHOOK, API_POLLING
  endpointUrl String? // External URL we're subscribed to

  // Configuration
  isActive       Boolean  @default(true)
  config         Json? // Provider-specific configuration (API keys, filters, etc.)
  filterPatterns String[] // URL patterns to filter incoming notifications

  // Webhook security
  secretKey String? // HMAC secret for signature verification
  authToken String? // Bearer token or API key
  verifySSL Boolean @default(true)

  // Metadata
  lastTriggeredAt DateTime?
  lastSuccessAt   DateTime?
  lastError       String?
  triggerCount    Int       @default(0)
  errorCount      Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations - source: soft ref to RegulatorySource in regulatory.prisma
  events WebhookEvent[]

  @@index([provider])
  @@index([webhookType])
  @@index([isActive])
  @@index([lastTriggeredAt])
}

// Webhook event log for received notifications
model WebhookEvent {
  id             String @id @default(cuid())
  subscriptionId String

  // Event details
  eventType   String // RSS_ITEM, EMAIL_NOTIFICATION, HTTP_POST, API_RESPONSE
  sourceUrl   String? // Original URL from notification
  contentUrl  String? // URL to fetch content from
  title       String?
  publishedAt DateTime?

  // Raw payload
  rawPayload String @db.Text // Full payload for debugging
  headers    Json? // HTTP headers

  // Processing status
  status       WebhookEventStatus @default(PENDING)
  processedAt  DateTime?
  errorMessage String?
  retryCount   Int                @default(0)

  // Evidence created
  evidenceId String? // Link to Evidence if created

  // Metadata
  receivedAt DateTime @default(now())

  // Relations
  subscription WebhookSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([status])
  @@index([receivedAt])
  @@index([eventType])
  @@index([evidenceId])
}

enum WebhookEventStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  DUPLICATE
  FILTERED
}

// Dead Letter Queue for cron job failures
model CronJobError {
  id           String    @id @default(cuid())
  jobName      String
  entityId     String?
  entityType   String?
  errorMessage String    @db.Text
  errorCode    String?
  attemptCount Int       @default(1)
  metadata     Json?
  resolvedAt   DateTime?
  resolvedBy   String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([jobName, entityId])
  @@index([jobName])
  @@index([entityId])
  @@index([resolvedAt])
  @@index([createdAt])
}

// ============================================================================
// ASSET REGISTRY & DEPRECIATION
// ============================================================================

model FixedAsset {
  id                 String             @id @default(cuid())
  companyId          String
  name               String
  category           AssetCategory
  acquisitionDate    DateTime
  acquisitionCost    Decimal            @db.Decimal(12, 2)
  salvageValue       Decimal            @default(0) @db.Decimal(12, 2)
  usefulLifeMonths   Int
  depreciationMethod DepreciationMethod
  status             AssetStatus        @default(ACTIVE)
  disposedAt         DateTime?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  company              Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  depreciationSchedule DepreciationSchedule?
  depreciationEntries  DepreciationEntry[]
  disposalEvents       DisposalEvent[]
  assetCandidates      AssetCandidate[]
  fixedAssetCandidates FixedAssetCandidate[]

  @@index([companyId])
  @@index([status])
  @@index([acquisitionDate])
}

model DepreciationSchedule {
  id                String                     @id @default(cuid())
  assetId           String                     @unique
  method            DepreciationMethod
  periodMonths      Int                        @default(1)
  startDate         DateTime
  endDate           DateTime
  totalDepreciation Decimal                    @db.Decimal(12, 2)
  status            DepreciationScheduleStatus @default(LOCKED)
  lockedAt          DateTime?
  createdAt         DateTime                   @default(now())

  asset   FixedAsset          @relation(fields: [assetId], references: [id], onDelete: Cascade)
  entries DepreciationEntry[]

  @@index([assetId])
  @@index([startDate])
  @@index([endDate])
}

model DepreciationEntry {
  id                String   @id @default(cuid())
  scheduleId        String
  assetId           String
  periodStart       DateTime
  periodEnd         DateTime
  sequence          Int
  amount            Decimal  @db.Decimal(12, 2)
  accumulatedAmount Decimal  @db.Decimal(12, 2)
  journalEntryId    String?
  createdAt         DateTime @default(now())

  schedule     DepreciationSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  asset        FixedAsset           @relation(fields: [assetId], references: [id], onDelete: Cascade)
  journalEntry JournalEntry?        @relation(fields: [journalEntryId], references: [id], onDelete: SetNull)

  @@unique([scheduleId, sequence])
  @@index([assetId, periodStart])
  @@index([periodEnd])
  @@index([journalEntryId])
}

model DisposalEvent {
  id           String   @id @default(cuid())
  assetId      String
  disposalDate DateTime
  proceeds     Decimal? @db.Decimal(12, 2)
  notes        String?
  createdAt    DateTime @default(now())

  asset FixedAsset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  @@index([assetId])
  @@index([disposalDate])
}

model AssetCandidate {
  id               String               @id @default(cuid())
  companyId        String
  source           AssetCandidateSource
  sourceReference  String
  name             String
  category         AssetCategory
  acquisitionDate  DateTime
  acquisitionCost  Decimal              @db.Decimal(12, 2)
  usefulLifeMonths Int?
  metadata         Json?
  status           AssetCandidateStatus @default(PENDING)
  convertedAssetId String?              @unique
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  company        Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  convertedAsset FixedAsset? @relation(fields: [convertedAssetId], references: [id])

  @@unique([companyId, source, sourceReference])
  @@index([status])
  @@index([companyId])
}

enum AssetCategory {
  BUILDING
  EQUIPMENT
  FURNITURE
  VEHICLE
  INTANGIBLE
  OTHER
}

enum AssetStatus {
  ACTIVE
  PAUSED
  DISPOSED
}

enum DepreciationMethod {
  STRAIGHT_LINE
  DECLINING_BALANCE
  MANUAL
}

enum DepreciationScheduleStatus {
  LOCKED
}

enum AssetCandidateStatus {
  PENDING
  CONVERTED
  REJECTED
}

enum AssetCandidateSource {
  PROCUREMENT
}

// =============================================================================
// OUTBOX PATTERN - Guaranteed Event Delivery
// =============================================================================

model OutboxEvent {
  id          String            @id @default(cuid())
  eventType   String // e.g., "article_job.started", "webhook.received", "system_status.refresh"
  payload     Json
  status      OutboxEventStatus @default(PENDING)
  attempts    Int               @default(0)
  maxAttempts Int               @default(5)
  lastError   String?
  processedAt DateTime?
  scheduledAt DateTime          @default(now()) // When to process (allows delayed events)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([status, scheduledAt]) // For polling pending events
  @@index([eventType, status]) // For type-specific queries
  @@index([createdAt]) // For cleanup/retention queries
}

enum OutboxEventStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// =============================================================================
// E-INVOICE PROVIDER SYNC STATE - Cursor persistence for inbound polling
// =============================================================================

model ProviderSyncState {
  id                   String            @id @default(cuid())
  companyId            String
  provider             String // e.g., "eposlovanje", "moj-eracun"
  direction            EInvoiceDirection
  lastSuccessfulPollAt DateTime
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt

  // Phase 3+: Integration account used for syncing
  integrationAccountId String?
  integrationAccount   IntegrationAccount? @relation(fields: [integrationAccountId], references: [id])

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, provider, direction])
  @@index([companyId])
  @@index([provider, direction])
  @@index([integrationAccountId])
}
