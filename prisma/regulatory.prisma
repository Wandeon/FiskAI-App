// prisma/regulatory.prisma
// OWNER: Prisma (regulatory client)
// Tables in this file are managed exclusively by the regulatory Prisma client.
// This schema is for the Regulatory Truth Layer (RTL) and system-wide tables.
// Do NOT add tenant-scoped tables here.
//
// Connection: Uses REGULATORY_DATABASE_URL (can be same DB initially, separate later)
// Client: dbReg (no tenant isolation)

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/regulatory-client"
}

datasource db {
  provider = "postgresql"
  // IMPORTANT: Only manage "regulatory" schema. Including "public" here
  // causes db push to DROP all tables in public (not defined in this file).
  // The core schema (schema.prisma) manages the public schema.
  schemas  = ["regulatory"]
}

// =============================================================================
// ENUMS
// =============================================================================

enum AlertSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW

  @@schema("regulatory")
}

enum AlertType {
  SOURCE_CHANGED
  SOURCE_UNAVAILABLE
  RULE_SUPERSEDED
  CONFLICT_DETECTED
  DEADLINE_APPROACHING
  CONFIDENCE_DEGRADED
  COVERAGE_GAP
  NEGATIVE_USER_FEEDBACK
  STRUCTURAL_DRIFT

  @@schema("regulatory")
}

// =============================================================================
// REGULATORY SOURCE - Root registry of monitored regulatory sources
// =============================================================================

model RegulatorySource {
  id                 String    @id @default(cuid())
  slug               String    @unique // e.g., "porezna-pausalni"
  name               String // "Porezna uprava - Paušalno oporezivanje"
  url                String
  hierarchy          Int       @default(5) // 1=Ustav, 2=Zakon, 3=Podzakonski, 4=Pravilnik, 5=Uputa, 6=Mišljenje, 7=Praksa
  fetchIntervalHours Int       @default(24)
  lastFetchedAt      DateTime?
  lastContentHash    String?
  isActive           Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  evidence         Evidence[]
  monitoringAlerts MonitoringAlert[]
  // NOTE: WebhookSubscription remains in core schema with soft reference to sourceId

  @@index([isActive])
  @@index([lastFetchedAt])
  @@schema("regulatory")
}

// =============================================================================
// EVIDENCE - Immutable source documents fetched from regulatory sources
// =============================================================================

model Evidence {
  id            String    @id @default(cuid())
  sourceId      String
  fetchedAt     DateTime  @default(now())
  contentHash   String
  rawContent    String    @db.Text // Full HTML/PDF text
  contentType   String    @default("html") // html, pdf, xml
  url           String
  hasChanged    Boolean   @default(false)
  changeSummary String?
  deletedAt     DateTime?

  // Staleness tracking for regulatory compliance
  lastVerifiedAt  DateTime? // Last time source URL was checked and content confirmed unchanged
  expiresAt       DateTime? // Explicit expiration date for evidence
  sourceEtag      String? // ETag from source for change detection
  sourceLastMod   DateTime? // Last-Modified header from source
  verifyCount     Int       @default(0) // Number of times verified unchanged
  stalenessStatus String    @default("FRESH") // FRESH, AGING, STALE, UNAVAILABLE, EXPIRED

  // Track consecutive HEAD failures for grace period
  consecutiveFailures Int @default(0) // Reset to 0 on success, increment on failure

  // OCR support fields
  contentClass          String  @default("HTML") // HTML, PDF_TEXT, PDF_SCANNED, DOC, XLSX, JSON
  ocrMetadata           Json? // OCR processing metadata
  primaryTextArtifactId String? // Points to canonical text artifact for Extractor

  // Semantic similarity support for duplicate detection
  embedding          Unsupported("vector(768)")? // Vector embedding for semantic duplicate detection
  embeddingStatus    String                      @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  embeddingError     String? // Error message if embedding generation failed
  embeddingAttempts  Int                         @default(0) // Number of embedding generation attempts
  embeddingUpdatedAt DateTime? // Last embedding status update

  // Instrument linking (nullable - can be backfilled by parser if not known at fetch time)
  instrumentId       String? // FK to Instrument

  source             RegulatorySource        @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  instrument         Instrument?             @relation(fields: [instrumentId], references: [id])
  artifacts          EvidenceArtifact[]
  extractionRejected ExtractionRejected[]
  // NOTE: Relations to models still in core schema (SourcePointer, AtomicClaim, etc.)
  // will be added back when those models are migrated in later batches

  @@unique([url, contentHash])
  @@index([sourceId])
  @@index([fetchedAt])
  @@index([contentHash])
  @@index([contentClass])
  @@index([stalenessStatus])
  @@index([expiresAt])
  @@index([lastVerifiedAt])
  @@index([embeddingStatus]) // For retry queue queries
  @@index([instrumentId]) // Query evidence by instrument
  @@schema("regulatory")
}

// =============================================================================
// EVIDENCE ARTIFACT - OCR outputs, cleaned text, extracted tables
// =============================================================================

model EvidenceArtifact {
  id          String   @id @default(cuid())
  evidenceId  String
  kind        String // PDF_TEXT, OCR_TEXT, OCR_HOCR, HTML_CLEANED, TABLE_JSON
  content     String   @db.Text
  contentHash String
  pageMap     Json? // Per-page metadata: [{page, confidence, method}]
  createdAt   DateTime @default(now())

  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@index([evidenceId])
  @@index([kind])
  @@index([createdAt])
  @@schema("regulatory")
}

// =============================================================================
// EXTRACTION REJECTED - Dead Letter Queue for failed extractions
// =============================================================================

model ExtractionRejected {
  id            String    @id @default(cuid())
  evidenceId    String
  rejectionType String // e.g., "INVALID_PERCENTAGE", "QUOTE_NOT_IN_EVIDENCE", "INVALID_DATE"
  rawOutput     Json // The raw LLM output that failed
  errorDetails  String // Specific error message
  attemptCount  Int       @default(1)
  lastAttemptAt DateTime  @default(now())
  resolvedAt    DateTime?
  createdAt     DateTime  @default(now())

  evidence Evidence @relation(fields: [evidenceId], references: [id])

  @@index([evidenceId])
  @@index([rejectionType])
  @@index([createdAt])
  @@schema("regulatory")
}

// =============================================================================
// CONFLICT RESOLUTION AUDIT - Detailed conflict resolution tracking
// =============================================================================

model ConflictResolutionAudit {
  id         String   @id @default(cuid())
  conflictId String
  ruleAId    String? // Soft reference to RegulatoryRule (still in core)
  ruleBId    String? // Soft reference to RegulatoryRule (still in core)
  resolution String // RULE_A_PREVAILS, RULE_B_PREVAILS, MERGE_RULES, ESCALATE_TO_HUMAN
  reason     String   @db.Text
  resolvedBy String // ARBITER_AGENT, HUMAN, SYSTEM
  resolvedAt DateTime @default(now())
  metadata   Json? // { authorityComparison, sourceComparison, temporalAnalysis, aiArbitration }

  @@index([conflictId])
  @@index([ruleAId])
  @@index([ruleBId])
  @@index([resolvedAt])
  @@schema("regulatory")
}

// =============================================================================
// MONITORING ALERT - RTL system alerts
// =============================================================================

model MonitoringAlert {
  id                  String        @id @default(cuid())
  severity            AlertSeverity
  type                AlertType
  affectedRuleIds     String[] // Soft references to RegulatoryRule IDs
  sourceId            String?
  description         String        @db.Text
  autoAction          Json? // { action, executed, result }
  metadata            Json? // Additional context data
  humanActionRequired Boolean       @default(false)
  acknowledgedBy      String?
  acknowledgedAt      DateTime?
  resolvedAt          DateTime?
  createdAt           DateTime      @default(now())

  source RegulatorySource? @relation(fields: [sourceId], references: [id])

  @@index([severity])
  @@index([type])
  @@index([sourceId])
  @@index([createdAt])
  @@index([resolvedAt])
  @@schema("regulatory")
}

// =============================================================================
// RULE VERSION BUNDLE - Fiscal rule tables and versions (migrated from core in PR#10)
// =============================================================================

model RuleTable {
  id          String   @id @default(cuid())
  key         String   @unique // VAT, MUNICIPALITY_INCOME_TAX, CONTRIBUTIONS, PER_DIEM, MILEAGE, JOPPD_CODEBOOK
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  versions RuleVersion[]

  @@index([key])
  @@map("rule_table")
  @@schema("regulatory")
}

model RuleVersion {
  id             String    @id @default(cuid())
  tableId        String
  version        String
  effectiveFrom  DateTime
  effectiveUntil DateTime?
  data           Json
  dataHash       String
  publishedAt    DateTime  @default(now())
  createdAt      DateTime  @default(now())

  table        RuleTable         @relation(fields: [tableId], references: [id], onDelete: Cascade)
  snapshots    RuleSnapshot[]
  calculations RuleCalculation[]
  // NOTE: TravelOrder relations remain in core schema with soft reference to ruleVersionId
  // NOTE: PayoutLine/JoppdSubmissionLine use AppliedRuleSnapshot, not direct relations (PR#9)

  @@unique([tableId, version])
  @@index([tableId, effectiveFrom])
  @@map("rule_version")
  @@schema("regulatory")
}

model RuleSnapshot {
  id            String   @id @default(cuid())
  ruleVersionId String
  data          Json
  dataHash      String
  createdAt     DateTime @default(now())

  ruleVersion RuleVersion @relation(fields: [ruleVersionId], references: [id], onDelete: Cascade)

  @@index([ruleVersionId])
  @@map("rule_snapshot")
  @@schema("regulatory")
}

model RuleCalculation {
  id            String   @id @default(cuid())
  ruleVersionId String
  tableKey      String
  input         Json
  result        Json
  referenceDate DateTime
  createdAt     DateTime @default(now())

  ruleVersion RuleVersion @relation(fields: [ruleVersionId], references: [id], onDelete: Cascade)

  @@index([tableKey])
  @@index([ruleVersionId])
  @@index([referenceDate])
  @@map("rule_calculation")
  @@schema("regulatory")
}

// =============================================================================
// PHASE-1: RULE FACT (Canonical Regulatory Truth)
// =============================================================================
// RuleFact is the canonical form of verified regulatory truth.
// See: docs/audits/PHASE_1_PROOF_RUN.md

enum RuleFactSubjectType {
  TAXPAYER
  EMPLOYER
  COMPANY
  INDIVIDUAL
  ALL

  @@schema("regulatory")
}

enum RuleFactObjectType {
  POREZNA_STOPA
  PRAG_PRIHODA
  OSNOVICA
  ROK
  OBVEZA
  IZNOS
  POSTOTAK

  @@schema("regulatory")
}

enum RuleFactValueType {
  PERCENTAGE
  CURRENCY_EUR
  CURRENCY_HRK
  DEADLINE_DAY
  DEADLINE_DESCRIPTION
  BOOLEAN
  COUNT

  @@schema("regulatory")
}

enum RuleFactAuthorityLevel {
  LAW
  GUIDANCE
  PROCEDURE
  PRACTICE

  @@schema("regulatory")
}

enum RuleFactRiskTier {
  T0
  T1
  T2
  T3

  @@schema("regulatory")
}

enum RuleFactStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  PUBLISHED
  DEPRECATED
  REJECTED

  @@schema("regulatory")
}

// =============================================================================
// DEPRECATED: RuleFact - Use RegulatoryRule (public schema) instead
// =============================================================================
// Phase-D Completion: RuleFact is deprecated as of 2026-01-16.
// RegulatoryRule in the public schema is now the single source of truth.
// RuleFact is retained ONLY for:
// - RuleFactSnapshot regression testing
// - Historical reference during migration period
// DO NOT write new code that reads from or writes to RuleFact.
// All new regulatory rule data flows through RegulatoryRule exclusively.
/// @deprecated Use RegulatoryRule (public schema) instead.
model RuleFact {
  id                 String                 @id @default(cuid())
  conceptSlug        String
  conceptId          String? // Soft ref to public.Concept
  subjectType        RuleFactSubjectType
  subjectDescription String
  subjectConstraints Json?                  @db.JsonB
  objectType         RuleFactObjectType
  objectDescription  String
  objectConstraints  Json?                  @db.JsonB
  conditions         Json                   @default("{\"always\": true}") @db.JsonB
  value              String
  valueType          RuleFactValueType
  displayValue       String
  effectiveFrom      DateTime
  effectiveUntil     DateTime?
  authority          RuleFactAuthorityLevel
  legalReference     Json                   @db.JsonB
  groundingQuotes    Json                   @db.JsonB
  riskTier           RuleFactRiskTier
  confidence         Float                  @default(0.90)
  status             RuleFactStatus         @default(DRAFT)
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt

  @@index([conceptSlug])
  @@index([status])
  @@index([effectiveFrom])
  @@index([riskTier])
  @@index([authority])
  @@index([conceptId])
  @@schema("regulatory")
}

// =============================================================================
// SCHEDULER RUN - Track expected vs actual job runs for catch-up logic
// =============================================================================
// Task 1.2: RTL Autonomy - Scheduler Run Persistence + Catch-up
// Tracks scheduled job runs to detect missed executions and enable catch-up.
// Uses row-level locking to prevent concurrent runs of the same job type.

enum SchedulerRunStatus {
  EXPECTED // Job is scheduled to run
  RUNNING // Job is currently executing (lock held)
  COMPLETED // Job finished successfully
  FAILED // Job finished with error
  MISSED // Job was skipped (lock contention or catch-up detected)

  @@schema("regulatory")
}

model SchedulerRun {
  id           String             @id @default(cuid())
  jobType      String // "discovery", "health-check", "confidence-decay", etc.
  scheduledAt  DateTime // When this run was scheduled to execute
  startedAt    DateTime? // When execution actually started
  completedAt  DateTime? // When execution finished (success or failure)
  status       SchedulerRunStatus @default(EXPECTED)
  errorMessage String? // Error details if FAILED
  lockHolder   String? // Instance ID holding the distributed lock

  @@unique([jobType, scheduledAt])
  @@index([jobType, status])
  @@index([scheduledAt])
  @@schema("regulatory")
}

// =============================================================================
// RULE FACT SNAPSHOT - Daily snapshots for regression detection
// =============================================================================
// Task 2.2: RTL Autonomy - Automated Regression Testing
// Creates daily snapshots of PUBLISHED RuleFacts to detect silent value changes.
// Compares against previous snapshot to identify unexplained changes.
//
// Critical Safeguards (Appendix A.6):
// - Retention Policy: Keep 90 days of snapshots, then archive
// - TTL Cleanup Job: Daily job to purge old snapshots
// - Diff Storage: After initial baseline, store diffs only
// - Index: snapshotAt index for efficient TTL queries

model RuleFactSnapshot {
  id              String   @id @default(cuid())
  ruleId          String // Soft ref to RuleFact.id (PUBLISHED rules only)
  conceptSlug     String // Denormalized for query efficiency
  valueHash       String // SHA-256 hash of the rule value
  confidence      Float // Confidence score at snapshot time
  sourceVersions  Json // Array of {evidenceId, contentHash} for diff explanation
  snapshotAt      DateTime @default(now())

  @@index([ruleId, snapshotAt]) // Query snapshots for a specific rule over time
  @@index([snapshotAt]) // TTL cleanup queries
  @@index([conceptSlug, snapshotAt]) // Query by concept slug
  @@schema("regulatory")
}

// =============================================================================
// RULE FEEDBACK - User feedback on AI assistant responses
// =============================================================================
// Task 4.1: RTL Autonomy - User Feedback Loop
// Tracks user feedback (thumbs up/down) on AI assistant responses to correlate
// feedback to specific regulatory rules and identify rules with poor accuracy.
//
// Critical Safeguards (Appendix A.4):
// - Minimal Data: Store only ruleId, sentiment, timestamp, appVersion, optional reasonCode
// - No PII: Do not store user identifiers by default
// - Hashed ID: If needed, use one-way salted hash with consent
// - Retention: 12-month retention policy
// - UI Opt-in: Requires privacy policy update and UI opt-in

model RuleFeedback {
  id                String   @id @default(cuid())
  ruleId            String // Soft ref to RegulatoryRule or RuleFact
  sentiment         String // "positive" | "negative"
  reasonCode        String? // Optional: "inaccurate" | "outdated" | "unclear" | "other"
  appVersion        String // Application version when feedback was given
  anonymousUserHash String? // SHA-256(salt + userId) ONLY if user consented
  createdAt         DateTime @default(now())

  @@index([ruleId])
  @@index([createdAt]) // For retention cleanup queries
  @@index([sentiment]) // For aggregation queries
  @@schema("regulatory")
}

// =============================================================================
// RULE REVALIDATION - Tracks scheduled revalidation of published rules
// =============================================================================
// Task 4.2: RTL Autonomy - Continuous Re-Validation
// Records each revalidation run for audit and tracking purposes.
// Revalidation runs the full validation suite on published rules based on risk tier:
// - T0: Weekly (7 days) - Critical compliance rules
// - T1: Bi-weekly (14 days) - High-risk rules
// - T2: Monthly (30 days) - Medium-risk rules
// - T3: Quarterly (90 days) - Low-risk rules
//
// Critical Safeguards:
// - All validations recorded for audit trail
// - Failed validations trigger MonitoringAlert with humanActionRequired=true
// - Retention: Keep 90 days of records for trend analysis

model RuleRevalidation {
  id              String   @id @default(cuid())
  ruleId          String // Soft ref to RuleFact.id
  validatedAt     DateTime @default(now())
  passed          Boolean
  failures        Json? // [{check, reason}] - only populated on failure
  validationSuite String // "full" | "quote-only" | "source-only" | etc.
  createdAt       DateTime @default(now())

  @@index([ruleId, validatedAt]) // Query revalidation history for a rule
  @@index([validatedAt]) // TTL cleanup queries
  @@index([passed]) // Query failed revalidations
  @@schema("regulatory")
}

// =============================================================================
// CONFIDENCE CALIBRATION - Platt scaling parameters for LLM confidence scores
// =============================================================================
// Task 4.3: RTL Autonomy - Confidence Calibration
// Stores learned Platt scaling parameters to calibrate raw LLM confidence scores
// based on historical human review outcomes.
//
// Platt Scaling: P(y=1|x) = 1 / (1 + exp(A*x + B))
// Where A and B are learned from historical data, x is raw confidence.
//
// Critical Safeguards:
// - Minimum sample size: 50 reviews required before calibration is applied
// - Parameters refreshed weekly via scheduled job
// - Cold-start handled gracefully (returns raw confidence unchanged)
// - Retention: Keep 90 days of calibration records for trend analysis

model ConfidenceCalibration {
  id         String   @id @default(cuid())
  paramA     Float // Platt scaling parameter A (slope)
  paramB     Float // Platt scaling parameter B (intercept)
  sampleSize Int // Number of reviews used to compute parameters
  computedAt DateTime @default(now())

  @@index([computedAt]) // Query latest calibration, TTL cleanup
  @@schema("regulatory")
}

// =============================================================================
// NN ENQUEUED JOB - Race-proof global idempotency registry
// =============================================================================
// Prevents duplicate enqueues across concurrent nn-sentinel runs.
// Insert-if-not-exists pattern: only enqueue if insert succeeds.
// This replaces audit-based idempotency which is brittle under summary mode.

model NNEnqueuedJob {
  jobKey              String   @id // nn:item:YYYY:ISSUE:ITEM - unique job identifier
  firstSeenAt         DateTime @default(now())
  firstSchedulerRunId String // The run that first enqueued this job
  latestSchedulerRunId String? // Updated if same job seen in later run (skipped)

  // Denormalized location for queries
  year  Int
  issue Int
  item  Int
  url   String?

  @@index([year, issue]) // Query by location
  @@index([firstSchedulerRunId]) // Query by run
  @@map("nn_enqueued_job")
  @@schema("regulatory")
}

// =============================================================================
// INSTRUMENT - Core law/regulation tracking with honest coverage
// =============================================================================
// Tracks Croatian legal instruments (zakoni, pravilnici, uredbe, odluke).
// Models the reality that we may not have complete historical coverage.
//
// Key concepts:
// - canonicalId: Deterministic ID for deduplication (eliUri ?? nnCanonicalKey)
// - coverageStart: Earliest text we have (honest about gaps)
// - baseline: Reference point for consolidation (may be later than original enactment)
// - status: Whether we can produce consolidated text or only cite deltas

model Instrument {
  id            String   @id @default(cuid())
  canonicalId   String   @unique // Deterministic: eliUri ?? nnCanonicalKey

  // Identity (at least one required, both allowed)
  eliUri        String?  @unique // eli/hr/zakon/2024/152/2505 (preferred)
  nnCanonicalKey String?  @unique // nn:2024:152:2505 (fallback)

  // Human-readable
  title         String            // "Zakon o porezu na dobit"
  shortTitle    String?           // "ZPD"

  // Coverage tracking (honest about what we have)
  coverageStartDate       DateTime?       // Earliest text date we have
  coverageStartEvidenceId String?         // FK to Evidence (soft ref)
  coverageStartType       InstrumentTextType @default(UNKNOWN)
  coverageGapNote         String?         // "Original 1993 enactment pre-dates NN digital archive"

  // Baseline state (reference point for consolidation)
  hasBaselineText         Boolean @default(false)
  baselineEvidenceId      String?         // FK to Evidence with baseline text (soft ref)
  baselineValidFrom       DateTime?       // When this baseline became effective

  // Consolidation status
  status        InstrumentStatus @default(DELTA_ONLY)

  // Metadata
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  evidence      Evidence[] // All evidence linked to this instrument

  @@index([status])
  @@index([coverageStartDate])
  @@index([createdAt])
  @@map("instrument")
  @@schema("regulatory")
}

enum InstrumentTextType {
  CONSOLIDATED  // pročišćeni tekst - official consolidated version
  AMENDMENT     // izmjene i dopune - changes to existing law
  ORIGINAL      // original enactment (rare to find in archive)
  UNKNOWN       // couldn't determine type
  @@schema("regulatory")
}

enum InstrumentStatus {
  DELTA_ONLY              // Have amendments but no baseline - can cite deltas, can't consolidate
  BASELINED               // Have a baseline text - can consolidate forward from it
  CONSOLIDATED_AVAILABLE  // Have official pročišćeni tekst
  @@schema("regulatory")
}

// =============================================================================
// NN SENTINEL CHECKPOINT - Resumable enumeration state per year
// =============================================================================
// Tracks progress of nn-sentinel enumeration runs.
// Allows resuming after failures without gaps or duplicates.

model NNSentinelCheckpoint {
  id                       String                      @id @default(cuid())
  schedulerRunId           String                      // FK to SchedulerRun (soft ref)
  year                     Int
  lastCompletedIssueNumber Int?                        // Last issue fully processed
  status                   NNSentinelCheckpointStatus  @default(RUNNING)
  anomalyCount             Int                         @default(0)
  totalIssuesDiscovered    Int                         @default(0)
  totalItemsEnqueued       Int                         @default(0)
  totalItemsSkipped        Int                         @default(0)
  createdAt                DateTime                    @default(now())
  updatedAt                DateTime                    @updatedAt

  @@unique([schedulerRunId, year])
  @@index([status])
  @@map("nn_sentinel_checkpoint")
  @@schema("regulatory")
}

enum NNSentinelCheckpointStatus {
  RUNNING    // Currently processing
  COMPLETED  // All issues processed
  PAUSED     // Stopped due to anomaly or error
  @@schema("regulatory")
}

// =============================================================================
// NN SENTINEL AUDIT EVENT - Immutable audit trail for enumeration decisions
// =============================================================================
// Every decision (enqueue, skip, pause) produces an audit event.
// Enables debugging, coverage analysis, and compliance reporting.

model NNSentinelAuditEvent {
  id              String                @id @default(cuid())
  schedulerRunId  String
  ts              DateTime              @default(now())
  eventType       NNSentinelEventType
  decision        NNSentinelDecision
  reasonCode      NNSentinelReasonCode

  // Location context (nullable depending on event stage)
  year            Int?
  issue           Int?
  item            Int?
  url             String?
  jobKey          String?

  // Additional details
  issueCount      Int?                  // For DISCOVERED_YEAR_ISSUES
  itemCount       Int?                  // For DISCOVERED_ISSUE_ITEMS
  details         Json?                 @db.JsonB

  @@index([schedulerRunId, ts])
  @@index([year, issue, item])
  @@index([jobKey])
  @@index([reasonCode])
  @@map("nn_sentinel_audit_event")
  @@schema("regulatory")
}

enum NNSentinelEventType {
  DISCOVERY  // Found issues/items
  ENQUEUE    // Enqueued a fetch job
  SKIP       // Skipped an item
  ANOMALY    // Detected anomaly
  ERROR      // Error occurred
  @@schema("regulatory")
}

enum NNSentinelDecision {
  INFO      // Informational event
  ENQUEUED  // Job was enqueued
  SKIPPED   // Job was skipped
  PAUSED    // Enumeration paused
  FAILED    // Operation failed
  @@schema("regulatory")
}

enum NNSentinelReasonCode {
  // Discovery events
  RUN_STARTED
  RUN_COMPLETED
  DISCOVERED_YEAR_ISSUES
  DISCOVERED_ISSUE_ITEMS
  ISSUE_SUMMARY
  CHECKPOINT_UPDATED

  // Enqueue events
  ENQUEUED_ITEM

  // Skip events
  SKIPPED_ALREADY_ENQUEUED
  SKIPPED_OUT_OF_RANGE

  // Anomaly events (trigger PAUSED)
  PAUSED_ANOMALY_NO_ISSUES
  PAUSED_ANOMALY_NO_ITEMS
  PAUSED_ANOMALY_DUPLICATE_KEYS

  // Error events
  FAILED_FETCH_LISTING

  // Mode switch
  SWITCHED_TO_SUMMARY_MODE

  @@schema("regulatory")
}
