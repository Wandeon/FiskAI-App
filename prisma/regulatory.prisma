// prisma/regulatory.prisma
// OWNER: Prisma (regulatory client)
// Tables in this file are managed exclusively by the regulatory Prisma client.
// This schema is for the Regulatory Truth Layer (RTL) and system-wide tables.
// Do NOT add tenant-scoped tables here.
//
// Connection: Uses REGULATORY_DATABASE_URL (can be same DB initially, separate later)
// Client: dbReg (no tenant isolation)

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/regulatory-client"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// ENUMS
// =============================================================================

enum AlertSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum AlertType {
  SOURCE_CHANGED
  SOURCE_UNAVAILABLE
  RULE_SUPERSEDED
  CONFLICT_DETECTED
  DEADLINE_APPROACHING
  CONFIDENCE_DEGRADED
  COVERAGE_GAP
}

// =============================================================================
// REGULATORY SOURCE - Root registry of monitored regulatory sources
// =============================================================================

model RegulatorySource {
  id                 String    @id @default(cuid())
  slug               String    @unique // e.g., "porezna-pausalni"
  name               String // "Porezna uprava - Paušalno oporezivanje"
  url                String
  hierarchy          Int       @default(5) // 1=Ustav, 2=Zakon, 3=Podzakonski, 4=Pravilnik, 5=Uputa, 6=Mišljenje, 7=Praksa
  fetchIntervalHours Int       @default(24)
  lastFetchedAt      DateTime?
  lastContentHash    String?
  isActive           Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  evidence         Evidence[]
  monitoringAlerts MonitoringAlert[]
  // NOTE: WebhookSubscription remains in core schema with soft reference to sourceId

  @@index([isActive])
  @@index([lastFetchedAt])
}

// =============================================================================
// EVIDENCE - Immutable source documents fetched from regulatory sources
// =============================================================================

model Evidence {
  id            String    @id @default(cuid())
  sourceId      String
  fetchedAt     DateTime  @default(now())
  contentHash   String
  rawContent    String    @db.Text // Full HTML/PDF text
  contentType   String    @default("html") // html, pdf, xml
  url           String
  hasChanged    Boolean   @default(false)
  changeSummary String?
  deletedAt     DateTime?

  // Staleness tracking for regulatory compliance
  lastVerifiedAt  DateTime? // Last time source URL was checked and content confirmed unchanged
  expiresAt       DateTime? // Explicit expiration date for evidence
  sourceEtag      String? // ETag from source for change detection
  sourceLastMod   DateTime? // Last-Modified header from source
  verifyCount     Int       @default(0) // Number of times verified unchanged
  stalenessStatus String    @default("FRESH") // FRESH, AGING, STALE, UNAVAILABLE, EXPIRED

  // Track consecutive HEAD failures for grace period
  consecutiveFailures Int @default(0) // Reset to 0 on success, increment on failure

  // OCR support fields
  contentClass          String  @default("HTML") // HTML, PDF_TEXT, PDF_SCANNED, DOC, XLSX, JSON
  ocrMetadata           Json? // OCR processing metadata
  primaryTextArtifactId String? // Points to canonical text artifact for Extractor

  // Semantic similarity support for duplicate detection
  embedding          Unsupported("vector(768)")? // Vector embedding for semantic duplicate detection
  embeddingStatus    String                      @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  embeddingError     String? // Error message if embedding generation failed
  embeddingAttempts  Int                         @default(0) // Number of embedding generation attempts
  embeddingUpdatedAt DateTime? // Last embedding status update

  source             RegulatorySource        @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  artifacts          EvidenceArtifact[]
  extractionRejected ExtractionRejected[]
  // NOTE: Relations to models still in core schema (SourcePointer, AtomicClaim, etc.)
  // will be added back when those models are migrated in later batches

  @@unique([url, contentHash])
  @@index([sourceId])
  @@index([fetchedAt])
  @@index([contentHash])
  @@index([contentClass])
  @@index([stalenessStatus])
  @@index([expiresAt])
  @@index([lastVerifiedAt])
  @@index([embeddingStatus]) // For retry queue queries
}

// =============================================================================
// EVIDENCE ARTIFACT - OCR outputs, cleaned text, extracted tables
// =============================================================================

model EvidenceArtifact {
  id          String   @id @default(cuid())
  evidenceId  String
  kind        String // PDF_TEXT, OCR_TEXT, OCR_HOCR, HTML_CLEANED, TABLE_JSON
  content     String   @db.Text
  contentHash String
  pageMap     Json? // Per-page metadata: [{page, confidence, method}]
  createdAt   DateTime @default(now())

  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@index([evidenceId])
  @@index([kind])
  @@index([createdAt])
}

// =============================================================================
// EXTRACTION REJECTED - Dead Letter Queue for failed extractions
// =============================================================================

model ExtractionRejected {
  id            String    @id @default(cuid())
  evidenceId    String
  rejectionType String // e.g., "INVALID_PERCENTAGE", "QUOTE_NOT_IN_EVIDENCE", "INVALID_DATE"
  rawOutput     Json // The raw LLM output that failed
  errorDetails  String // Specific error message
  attemptCount  Int       @default(1)
  lastAttemptAt DateTime  @default(now())
  resolvedAt    DateTime?
  createdAt     DateTime  @default(now())

  evidence Evidence @relation(fields: [evidenceId], references: [id])

  @@index([evidenceId])
  @@index([rejectionType])
  @@index([createdAt])
}

// =============================================================================
// CONFLICT RESOLUTION AUDIT - Detailed conflict resolution tracking
// =============================================================================

model ConflictResolutionAudit {
  id         String   @id @default(cuid())
  conflictId String
  ruleAId    String? // Soft reference to RegulatoryRule (still in core)
  ruleBId    String? // Soft reference to RegulatoryRule (still in core)
  resolution String // RULE_A_PREVAILS, RULE_B_PREVAILS, MERGE_RULES, ESCALATE_TO_HUMAN
  reason     String   @db.Text
  resolvedBy String // ARBITER_AGENT, HUMAN, SYSTEM
  resolvedAt DateTime @default(now())
  metadata   Json? // { authorityComparison, sourceComparison, temporalAnalysis, aiArbitration }

  @@index([conflictId])
  @@index([ruleAId])
  @@index([ruleBId])
  @@index([resolvedAt])
}

// =============================================================================
// MONITORING ALERT - RTL system alerts
// =============================================================================

model MonitoringAlert {
  id                  String        @id @default(cuid())
  severity            AlertSeverity
  type                AlertType
  affectedRuleIds     String[] // Soft references to RegulatoryRule IDs
  sourceId            String?
  description         String        @db.Text
  autoAction          Json? // { action, executed, result }
  humanActionRequired Boolean       @default(false)
  acknowledgedBy      String?
  acknowledgedAt      DateTime?
  resolvedAt          DateTime?
  createdAt           DateTime      @default(now())

  source RegulatorySource? @relation(fields: [sourceId], references: [id])

  @@index([severity])
  @@index([type])
  @@index([sourceId])
  @@index([createdAt])
  @@index([resolvedAt])
}

// =============================================================================
// RULE VERSION BUNDLE - Fiscal rule tables and versions (migrated from core in PR#10)
// =============================================================================

model RuleTable {
  id          String   @id @default(cuid())
  key         String   @unique // VAT, MUNICIPALITY_INCOME_TAX, CONTRIBUTIONS, PER_DIEM, MILEAGE, JOPPD_CODEBOOK
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  versions RuleVersion[]

  @@index([key])
  @@map("rule_table")
}

model RuleVersion {
  id             String    @id @default(cuid())
  tableId        String
  version        String
  effectiveFrom  DateTime
  effectiveUntil DateTime?
  data           Json
  dataHash       String
  publishedAt    DateTime  @default(now())
  createdAt      DateTime  @default(now())

  table        RuleTable         @relation(fields: [tableId], references: [id], onDelete: Cascade)
  snapshots    RuleSnapshot[]
  calculations RuleCalculation[]
  // NOTE: TravelOrder relations remain in core schema with soft reference to ruleVersionId
  // NOTE: PayoutLine/JoppdSubmissionLine use AppliedRuleSnapshot, not direct relations (PR#9)

  @@unique([tableId, version])
  @@index([tableId, effectiveFrom])
  @@map("rule_version")
}

model RuleSnapshot {
  id            String   @id @default(cuid())
  ruleVersionId String
  data          Json
  dataHash      String
  createdAt     DateTime @default(now())

  ruleVersion RuleVersion @relation(fields: [ruleVersionId], references: [id], onDelete: Cascade)

  @@index([ruleVersionId])
  @@map("rule_snapshot")
}

model RuleCalculation {
  id            String   @id @default(cuid())
  ruleVersionId String
  tableKey      String
  input         Json
  result        Json
  referenceDate DateTime
  createdAt     DateTime @default(now())

  ruleVersion RuleVersion @relation(fields: [ruleVersionId], references: [id], onDelete: Cascade)

  @@index([tableKey])
  @@index([ruleVersionId])
  @@index([referenceDate])
  @@map("rule_calculation")
}
