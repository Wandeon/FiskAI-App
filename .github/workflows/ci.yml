name: CI

on:
  push:
    branches: ["main", "develop", "feature/*"]
  pull_request:

env:
  NODE_VERSION: "20"
  # Required for prisma generate during npm postinstall
  DATABASE_URL: "postgresql://ci:ci@localhost:5432/ci?schema=public"

jobs:
  lint:
    name: Lint & Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Validate Prisma schema
        run: npx prisma validate

      - name: Run lint
        # TECH DEBT: 500 warnings ceiling matches existing codebase state
        # TODO: Create lint baseline file and ratchet down over time (like lint-ratchet does)
        # See issue: #XXX for tracking lint debt reduction
        run: npx eslint src --ext .ts,.tsx --max-warnings=500
        env:
          NODE_OPTIONS: "--max-old-space-size=8192"

      - name: Check formatting
        run: npm run format:check

      - name: Check no ruleVersion relations (PR#9 guardrail)
        run: npx tsx scripts/check-no-ruleversion-relations.ts

      - name: Check no direct core RuleVersion usage (PR#11 guardrail)
        run: npx tsx scripts/check-no-direct-core-ruleversion.ts

      - name: Check no legacy secret access (Phase 5 guardrail)
        run: npx tsx scripts/check-legacy-secrets.ts

  lint-ratchet:
    name: Lint Ratchet
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Run lint ratchet check
        run: |
          set -euo pipefail

          # Run ESLint on scoped paths (use find to handle parentheses in path)
          find "src/app/(admin)" -name "*.ts" -o -name "*.tsx" | \
            xargs npx eslint --format json > eslint-ratchet-report.json 2>&1 || true

          # Verify output exists
          if [ ! -s eslint-ratchet-report.json ]; then
            echo "::error::ESLint produced no output - possible crash"
            exit 1
          fi

          # Count violations
          ANY_COUNT=$(jq '[.[].messages[] | select(.ruleId == "@typescript-eslint/no-explicit-any")] | length' eslint-ratchet-report.json)

          # Get baseline (fail if missing)
          if [ ! -f .eslint-baseline.json ]; then
            echo "::error::Baseline file .eslint-baseline.json not found"
            exit 1
          fi

          BASELINE=$(jq -r '.ratchets[] | select(.rule=="@typescript-eslint/no-explicit-any") | .ceiling' .eslint-baseline.json)

          if [ -z "$BASELINE" ] || [ "$BASELINE" = "null" ]; then
            echo "::error::No baseline ceiling found for no-explicit-any"
            exit 1
          fi

          echo "Current: $ANY_COUNT | Ceiling: $BASELINE"

          if [ "$ANY_COUNT" -gt "$BASELINE" ]; then
            echo "::error::Lint ratchet FAILED: no-explicit-any increased from $BASELINE to $ANY_COUNT"
            exit 1
          fi

          if [ "$ANY_COUNT" -lt "$BASELINE" ]; then
            echo "::notice::Lint debt reduced! Consider updating baseline: $ANY_COUNT < $BASELINE"
          fi

          echo "âœ… Lint ratchet passed"

  typecheck:
    name: TypeScript Check
    runs-on: ubuntu-latest
    # BLOCKING: TypeScript errors now fail the build (Phase 0 Architecture Containment)
    # Zero tolerance for type errors - all errors must be fixed before merge
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Type check
        run: npx tsc --noEmit
        env:
          NODE_OPTIONS: "--max-old-space-size=8192"

  security:
    name: Security Audit
    runs-on: ubuntu-latest
    # CRITICAL: Security audit must block deployments
    # Removed continue-on-error per issue #324
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Security audit
        # Note: xlsx package has known high vulnerability (GHSA-4r6h-8v6p-xvw6) with no fix available
        # Using critical level until alternative package is evaluated (tracked in issue)
        run: npm audit --audit-level=critical

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Check test-DB boundary (guardrail)
        run: npx tsx scripts/check-test-db-boundary.ts

      - name: Run unit tests
        run: npm run test:unit

  test-property:
    name: Property-Based Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Run property-based tests
        run: npm run test:property

  test-golden:
    name: Golden Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Run golden tests
        run: npm run test:golden

      - name: Check for uncommitted fixture changes
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "::error::Golden fixtures were updated. Please commit them."
            echo "Changed files:"
            git status --porcelain
            git diff
            exit 1
          fi

  test-integration:
    name: Integration Tests (DB)
    runs-on: ubuntu-latest
    # Phase 8: Made blocking - integration tests must pass
    services:
      postgres:
        image: pgvector/pgvector:pg16
        env:
          POSTGRES_USER: ci
          POSTGRES_PASSWORD: ci
          POSTGRES_DB: ci
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    env:
      DATABASE_URL: "postgresql://ci:ci@localhost:5432/ci"
      REGULATORY_DATABASE_URL: "postgresql://ci:ci@localhost:5432/ci?schema=regulatory"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma clients (core + regulatory)
        run: |
          npx prisma generate
          npx prisma generate --schema=prisma/regulatory.prisma

      - name: Enable pgvector extension
        run: PGPASSWORD=ci psql -h localhost -U ci -d ci -c "CREATE EXTENSION IF NOT EXISTS vector;"

      - name: Create regulatory schema
        run: PGPASSWORD=ci psql -h localhost -U ci -d ci -c "CREATE SCHEMA IF NOT EXISTS regulatory;"

      - name: Apply core schema
        run: npx prisma db push --accept-data-loss

      - name: Apply regulatory schema
        run: npx prisma db push --schema=prisma/regulatory.prisma --accept-data-loss

      - name: Run integration tests
        run: node --import tsx --test src/lib/regulatory-truth/__tests__/*.test.ts

      - name: Regulatory Trust Summary
        if: always()
        run: |
          echo "## ðŸ”’ Regulatory Trust Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Gate | Threshold | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| extractor_parse_failure_rate | >10% CRITICAL | âœ… Tested |" >> $GITHUB_STEP_SUMMARY
          echo "| validator_rejection_rate | >35% CRITICAL | âœ… Tested |" >> $GITHUB_STEP_SUMMARY
          echo "| t0_t1_approval_compliance | >0 CRITICAL | âœ… Tested |" >> $GITHUB_STEP_SUMMARY
          echo "| source_pointer_coverage_published | >0 CRITICAL | âœ… Tested |" >> $GITHUB_STEP_SUMMARY
          echo "| citation_compliance | â‰¥95% (28/30) | âœ… Tested |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "See \`docs/regulatory-truth/evidence-pack-2025-12-23.md\` for full details." >> $GITHUB_STEP_SUMMARY

  test-db:
    name: DB Vitest Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: pgvector/pgvector:pg16
        env:
          POSTGRES_USER: ci
          POSTGRES_PASSWORD: ci
          POSTGRES_DB: ci
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgresql://ci:ci@localhost:5432/ci
      REGULATORY_DATABASE_URL: postgresql://ci:ci@localhost:5432/ci?schema=regulatory
      INTEGRATION_VAULT_KEY: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma clients (core + regulatory)
        run: |
          npx prisma generate
          npx prisma generate --schema=prisma/regulatory.prisma

      - name: Enable pgvector extension
        run: PGPASSWORD=ci psql -h localhost -U ci -d ci -c "CREATE EXTENSION IF NOT EXISTS vector;"

      - name: Create regulatory schema
        run: PGPASSWORD=ci psql -h localhost -U ci -d ci -c "CREATE SCHEMA IF NOT EXISTS regulatory;"

      - name: Apply schemas with verification
        run: |
          set -e

          echo "=== Applying core schema ==="
          npx prisma db push --accept-data-loss --schema=prisma/schema.prisma 2>&1

          # Verify tables were created
          echo "Verifying core tables..."
          for i in 1 2 3 4 5; do
            CORE_COUNT=$(PGPASSWORD=ci psql -h localhost -U ci -d ci -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
            CORE_COUNT=$(echo "$CORE_COUNT" | tr -d ' ')
            echo "Attempt $i: Found $CORE_COUNT tables in public schema"
            if [ "$CORE_COUNT" -ge 100 ]; then
              echo "âœ… Core schema verified ($CORE_COUNT tables)"
              break
            fi
            if [ "$i" -eq 5 ]; then
              echo "::error::Failed to create core schema tables after 5 attempts"
              exit 1
            fi
            echo "Waiting and retrying..."
            sleep 2
          done

          echo ""
          echo "=== Applying regulatory schema ==="
          npx prisma db push --schema=prisma/regulatory.prisma --accept-data-loss 2>&1

          # Verify regulatory tables
          echo "Verifying regulatory tables..."
          sleep 1
          PGPASSWORD=ci psql -h localhost -U ci -d ci -c "\dt regulatory.*" || echo "(no regulatory tables)"

          echo ""
          echo "=== Final verification ==="
          PGPASSWORD=ci psql -h localhost -U ci -d ci -c "SELECT table_schema, COUNT(*) as count FROM information_schema.tables WHERE table_schema IN ('public', 'regulatory') GROUP BY table_schema;"

      - name: Schema sanity check
        run: |
          echo "Final verification..."

          # Check core tables
          echo "Checking core schema tables..."
          CORE_COUNT=$(PGPASSWORD=ci psql -h localhost -U ci -d ci -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
          echo "Tables in public schema: $CORE_COUNT"
          if [ "$CORE_COUNT" -lt 1 ]; then
            echo "::error::No tables in public schema - core schema setup failed"
            exit 1
          fi
          PGPASSWORD=ci psql -h localhost -U ci -d ci -c "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'User';" | grep -q "User" || {
            echo "::error::public.User table does not exist - core schema setup failed"
            exit 1
          }
          echo "âœ… Core schema verified"

          # Check regulatory tables
          echo "Checking regulatory schema tables..."
          PGPASSWORD=ci psql -h localhost -U ci -d ci -c "\dt regulatory.*" | grep -q "rule_table" || {
            echo "::error::regulatory.rule_table does not exist - regulatory schema setup failed"
            exit 1
          }
          echo "âœ… Regulatory schema verified"

          echo "âœ… All schema sanity checks passed"

      - name: Run DB vitest tests
        run: npm run test:db

  acceptance-tests:
    name: Acceptance Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: pgvector/pgvector:pg16
        env:
          POSTGRES_USER: ci
          POSTGRES_PASSWORD: ci
          POSTGRES_DB: ci
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgresql://ci:ci@localhost:5432/ci
      REGULATORY_DATABASE_URL: postgresql://ci:ci@localhost:5432/ci?schema=regulatory

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma clients (core + regulatory)
        run: |
          npx prisma generate
          npx prisma generate --schema=prisma/regulatory.prisma

      - name: Enable pgvector extension
        run: PGPASSWORD=ci psql -h localhost -U ci -d ci -c "CREATE EXTENSION IF NOT EXISTS vector;"

      - name: Create regulatory schema
        run: PGPASSWORD=ci psql -h localhost -U ci -d ci -c "CREATE SCHEMA IF NOT EXISTS regulatory;"

      - name: Apply core schema
        run: npx prisma db push --accept-data-loss

      - name: Apply regulatory schema
        run: npx prisma db push --schema=prisma/regulatory.prisma --accept-data-loss

      - name: Run acceptance tests
        run: node --import tsx --test acceptance/*.test.ts

  architecture-check:
    name: Architecture Compliance
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check no UI imports DB
        run: |
          echo "Checking for database imports in UI components..."
          if grep -r '@prisma/client' src/components/ 2>/dev/null | grep -v "containment: removed"; then
            echo "::error::UI components cannot import @prisma/client"
            exit 1
          fi
          if grep -r 'from "@/lib/db"' src/components/ 2>/dev/null; then
            echo "::error::UI components cannot import from @/lib/db"
            exit 1
          fi
          echo "âœ… No DB imports in UI components"

      - name: Check no floats in domain/application
        run: |
          echo "Checking for float operations in domain/application..."
          # Check for parseFloat (but not in comments or strings)
          if grep -rE '^\s*[^/]*parseFloat\(' src/domain/ src/application/ 2>/dev/null; then
            echo "::error::parseFloat banned in domain/application"
            exit 1
          fi
          # Check for .toFixed() (but allow Decimal.toFixed which is safe)
          if grep -rE '\.toFixed\(' src/domain/ src/application/ 2>/dev/null | grep -v 'Decimal'; then
            echo "::error::.toFixed() banned in domain/application"
            exit 1
          fi
          echo "âœ… No float operations in domain/application"

      - name: Check domain has no infra imports
        run: |
          echo "Checking domain layer purity..."
          # Only check TypeScript files, not markdown documentation
          if grep -r --include='*.ts' --include='*.tsx' '@prisma/client' src/domain/ 2>/dev/null; then
            echo "::error::Domain cannot import @prisma/client"
            exit 1
          fi
          if grep -r --include='*.ts' --include='*.tsx' 'from "@/lib/db"' src/domain/ 2>/dev/null; then
            echo "::error::Domain cannot import from @/lib/db"
            exit 1
          fi
          if grep -rE --include='*.ts' --include='*.tsx' 'from "next/' src/domain/ 2>/dev/null; then
            echo "::error::Domain cannot import Next.js"
            exit 1
          fi
          echo "âœ… Domain layer is pure"

      - name: Check no VAT calculations in UI
        run: |
          echo "Checking for VAT calculations in UI..."
          # Check for direct VAT arithmetic in components (vatRate / 100 pattern)
          VAT_VIOLATIONS=$(grep -rE 'vatRate.*\/ *100|taxRate.*\/ *100' src/components/ src/app/\(app\)/ 2>/dev/null | wc -l)
          if [ "$VAT_VIOLATIONS" -gt 0 ]; then
            echo "::warning::Found $VAT_VIOLATIONS potential VAT calculation(s) in UI"
            echo "UI should use InvoiceDisplayAdapter for VAT calculations"
            grep -rE 'vatRate.*\/ *100|taxRate.*\/ *100' src/components/ src/app/\(app\)/ 2>/dev/null || true
          fi
          echo "âœ… VAT calculation check complete (found $VAT_VIOLATIONS potential issues)"

      - name: Check UI uses domain adapters
        run: |
          echo "Checking UI imports domain layer correctly..."
          # Check for direct Money/VatRate imports in components
          DIRECT_IMPORTS=$(grep -rE 'from "@/domain/shared/(Money|VatRate)"' src/components/ src/app/\(app\)/ 2>/dev/null | wc -l)
          if [ "$DIRECT_IMPORTS" -gt 0 ]; then
            echo "::warning::Found $DIRECT_IMPORTS direct domain imports in UI"
            echo "UI should use @/interfaces/invoicing/InvoiceDisplayAdapter"
            grep -rE 'from "@/domain/shared/(Money|VatRate)"' src/components/ src/app/\(app\)/ 2>/dev/null || true
          fi
          echo "âœ… Domain adapter check complete (found $DIRECT_IMPORTS direct imports)"

      # Phase 2 Marketing Static Separation - Boundary Enforcement
      - name: Check marketing has no database imports
        run: |
          echo "Checking marketing routes have no database imports..."
          VIOLATIONS=0

          # Check for @/lib/db imports
          if grep -r --include='*.ts' --include='*.tsx' 'from "@/lib/db' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot import from @/lib/db"
            VIOLATIONS=$((VIOLATIONS + 1))
          fi

          # Check for drizzle-orm imports
          if grep -r --include='*.ts' --include='*.tsx' 'from "drizzle-orm' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot import drizzle-orm"
            VIOLATIONS=$((VIOLATIONS + 1))
          fi

          # Check for @prisma/client imports
          if grep -r --include='*.ts' --include='*.tsx' '@prisma/client' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot import @prisma/client"
            VIOLATIONS=$((VIOLATIONS + 1))
          fi

          if [ "$VIOLATIONS" -gt 0 ]; then
            echo "::error::Found $VIOLATIONS database import violations in marketing"
            exit 1
          fi
          echo "âœ… Marketing has no database imports"

      - name: Check marketing has no auth imports
        run: |
          echo "Checking marketing routes have no auth imports..."
          # Check for @/lib/auth imports
          if grep -r --include='*.ts' --include='*.tsx' 'from "@/lib/auth' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot import from @/lib/auth - auth lives on app.fiskai.hr only"
            grep -r --include='*.ts' --include='*.tsx' 'from "@/lib/auth' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null || true
            exit 1
          fi
          echo "âœ… Marketing has no auth imports"

      - name: Check marketing has no server actions
        run: |
          echo "Checking marketing routes have no server action imports..."
          # Check for @/app/actions imports
          if grep -r --include='*.ts' --include='*.tsx' 'from "@/app/actions' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot import server actions - static export has no server"
            grep -r --include='*.ts' --include='*.tsx' 'from "@/app/actions' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null || true
            exit 1
          fi

          # Check for "use server" directive
          if grep -r --include='*.ts' --include='*.tsx' '"use server"' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot use 'use server' directive - static export has no server"
            exit 1
          fi
          echo "âœ… Marketing has no server actions"

      - name: Check marketing has no force-dynamic
        run: |
          echo "Checking marketing routes have no force-dynamic..."
          # Look for the actual export statement, not just the string in comments
          if grep -rE --include='*.ts' --include='*.tsx' 'dynamic\s*=\s*["\x27]force-dynamic["\x27]' src/app/\(marketing\)/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot use force-dynamic - must be statically renderable"
            grep -rE --include='*.ts' --include='*.tsx' 'dynamic\s*=\s*["\x27]force-dynamic["\x27]' src/app/\(marketing\)/ 2>/dev/null || true
            exit 1
          fi
          echo "âœ… Marketing has no force-dynamic"

      - name: Check marketing has no next/server imports
        run: |
          echo "Checking marketing routes have no next/server imports..."
          # Check for next/server imports (cookies, headers, etc)
          if grep -r --include='*.ts' --include='*.tsx' 'from "next/server' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot import from next/server - static export has no server"
            exit 1
          fi
          # Check for next/headers
          if grep -r --include='*.ts' --include='*.tsx' 'from "next/headers' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v '.test.'; then
            echo "::error::Marketing cannot import from next/headers - static export has no server to read headers"
            exit 1
          fi
          echo "âœ… Marketing has no next/server imports"

      - name: Check marketing has no server-only env access
        run: |
          echo "Checking marketing routes have no server-only env access..."
          # Check for process.env without NEXT_PUBLIC_ prefix (excluding legitimate build-time constants)
          # This is a heuristic check - ESLint handles the precise enforcement
          SERVER_ENV=$(grep -r --include='*.ts' --include='*.tsx' 'process\.env\.' src/app/\(marketing\)/ src/components/marketing/ 2>/dev/null | grep -v 'NEXT_PUBLIC_' | grep -v '.test.' | grep -v '// static-safe' || true)
          if [ -n "$SERVER_ENV" ]; then
            echo "::warning::Potential server-only env access in marketing:"
            echo "$SERVER_ENV"
            echo "Marketing can only access NEXT_PUBLIC_* env vars at runtime"
          fi
          echo "âœ… Server-only env access check complete"

  build:
    name: Build
    runs-on: ubuntu-latest
    # Build is the deploy blocker - catches actual compilation errors
    # Added security as dependency per issue #324
    # Added typecheck as dependency per Phase 0 Architecture Containment
    # Added property and golden tests as dependencies per Phase 7 Testing Expansion
    # Phase 8: test-integration and architecture-check now blocking
    needs:
      [
        lint,
        typecheck,
        test,
        test-property,
        test-golden,
        test-integration,
        architecture-check,
        security,
      ]
    # Note: test-db runs in parallel and is a required merge check,
    # but doesn't block build to reduce critical path time
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Build application
        run: npm run build
        env:
          NODE_OPTIONS: "--max-old-space-size=4096"
          SENTRY_SKIP_SOURCE_MAP_UPLOAD: "true"
          # Required for build - dummy values for CI only
          RESEND_API_KEY: "re_test_dummy_key"
          REDIS_URL: "redis://localhost:6379"
          NEXTAUTH_SECRET: "ci-test-secret-not-for-production"
          NEXTAUTH_URL: "http://localhost:3000"
          # Regulatory database uses same dummy URL as main in CI
          REGULATORY_DATABASE_URL: "postgresql://ci:ci@localhost:5432/ci?schema=regulatory"

  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [lint, test, build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: fiskai:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # NOTE: Marketing Static Export moved to separate repo
  # See: https://github.com/Wandeon/fiskai-marketing
